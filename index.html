<!-- Визуальный Просмотрщик Новелл с исправлением логики затемнения спрайтов, возможностью смены темы, историей диалогов и поддержкой нескольких языков -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Архив сюжета Houkai Gakuen 2</title>
    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        /* ==================================================================== */
        /* === Цветовые переменные (Dark Theme - по умолчанию) === */
        /* ==================================================================== */
        :root, .dark-theme {
            /* Фоновые цвета */
            --color-bg-darkest: #171c26; /* Для заголовка и истории */
            --color-bg-main: #1f2937;    /* Основной фон/элементы (VN Viewer default) */
            --color-bg-medium: #374151;  /* Панель управления/Фон элемента истории */
            
            /* Акценты */
            --color-accent-primary: #0891b2; /* Бирюзовый (Load button / Активный элемент истории) */
            --color-accent-secondary: #0e7490; /* Темный Бирюзовый (Reset button) */
            --color-accent-ring: #22d3ee; /* Светлый Бирюзовый (Focus/Hover ring) */
            
            /* Текст */
            --color-text-primary: #e5e7eb; /* Светлый текст */
            --color-text-secondary: #d1d5db; /* Вспомогательный текст */
            
            /* Фиолетовый (Не тронут) */
            --color-speaker-name: #ca7cfe; 
        }

        /* ==================================================================== */
        /* === Цветовые переменные (Light Theme) - Оптимизировано === */
        /* ==================================================================== */
        .light-theme {
            /* Фоновые цвета */
            --color-bg-darkest: #ffffff;  /* Самый светлый Header и история */
            --color-bg-main: #f3f4f6;    /* Очень светлый основной фон (VN Viewer default) */
            --color-bg-medium: #ffffff;  /* Control Panel/Фон элемента истории */
            
            /* Акценты */
            --color-accent-primary: #0f766e; /* Темный Бирюзовый (Активный элемент истории) */
            --color-accent-secondary: #115e59; /* Более темный (Reset button) */
            --color-accent-ring: #0d9488; /* Акцент для фокуса */
            
            /* Текст - УЛУЧШЕННЫЙ КОНТРАСТ */
            --color-text-primary: #111827; /* Очень темный текст */
            --color-text-secondary: #4b5563; /* Средне-темный текст */
            
            /* Фиолетовый (Сделан темнее для контраста на светлом фоне) */
            --color-speaker-name: #9333ea; 
        }

        /* ==================================================================== */
        /* === Общие стили и привязка к переменным === */
        /* ==================================================================== */
        
        body, #vnViewer, .sprite-image {
            user-select: none;
            -webkit-user-select: none; 
            -moz-user-select: none;
            -ms-user-select: none;
            user-drag: none;
            -webkit-user-drag: none;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-main); 
            color: var(--color-text-primary);
            transition: background-color 0.3s ease;
        }
        
        /* Стили для UI-элементов */
        .vn-overlay {
            /* Используем основной цвет фона с легкой прозрачностью */
            background-color: var(--color-bg-main); 
            opacity: 0.9;
            backdrop-filter: blur(4px);
            color: var(--color-text-primary);
            border: 1px solid var(--color-bg-medium); /* Добавляем тонкую границу для светлой темы */
        }
        .speaker-name {
            background-color: var(--color-bg-main);
            color: var(--color-speaker-name); 
            padding: 4px 12px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: inline-block;
            font-weight: bold;
            font-size: 1.25rem;
        }
        
        /* Кнопки и селекты */
        .control-panel { background-color: var(--color-bg-medium); }
        .select-field { 
            /* Применяем цвет текста в зависимости от темы, перекрывая Tailwind */
            color: var(--color-text-primary); 
            background-color: var(--color-bg-main); 
            -webkit-appearance: none; /* Сброс стандартного стиля для лучшего контроля */
            appearance: none;
        }
        .select-field:hover, .select-field:focus { 
            box-shadow: 0 0 0 2px var(--color-accent-ring);
            border-color: var(--color-accent-ring);
        }
        
        /* Акцентные кнопки */
        .reset-button { background-color: var(--color-accent-secondary); }
        .reset-button:hover { background-color: var(--color-accent-primary); }
        .load-button { background-color: var(--color-accent-primary); }
        .load-button:hover { background-color: var(--color-accent-secondary); }
        .alert-message { background-color: var(--color-accent-primary); }


        /* ==================================================================== */
        /* === Спрайты и Фон === */
        /* ==================================================================== */
        
        /* Sprite Container покрывает весь #vnViewer */
        .sprite-position {
            position: absolute;
            bottom: 0; /* Привязан к самому низу #vnViewer */
            height: 95%; 
            width: 45%;
            transition: opacity 0.5s ease; 
            z-index: 10;
            display: flex; 
            justify-content: center;
            align-items: flex-end;
        }
        .sprite-position.left { left: 0; }
        .sprite-position.right { right: 0; }
        
        .sprite-image {
            height: 100%; 
            width: auto;
            max-height: 100%; 
            object-fit: contain;
            display: block; 
            /* Стиль затемнения: теперь opacity и filter */
            transition: opacity 0.3s ease, filter 0.3s ease; 
            opacity: 1; /* По умолчанию полная видимость */
        }
        
        /* ИСПРАВЛЕНИЕ: Затемняет изображение, но сохраняет полную непрозрачность */
        .dimmed-sprite {
            /* Затемнение яркости до 30% и легкое обесцвечивание */
            filter: brightness(0.3) grayscale(30%) !important; 
            opacity: 1 !important; /* Важно: сохраняем полную непрозрачность */
        }
        
        .bg-layer {
            transition: opacity 1.0s ease; 
            background-repeat: no-repeat;
            background-position: center;
            background-size: cover;
        }
        #vnViewer {
            background-color: var(--color-bg-main); 
        }

        /* ==================================================================== */
        /* === ИСТОРИЯ ДИАЛОГОВ (ОБНОВЛЕНИЕ: ВПРАВО, ШИРЕ, СКРОЛЛБАР) === */
        /* ==================================================================== */
        
        #historyPanel.open {
            transform: translateX(0); /* Показать: вернуть на место */
        }
        #historyPanel {
            /* Позиционирование справа */
            right: 0; 
            left: auto; /* Отменяем левую привязку */
            top: 0;
            
            /* Скрыть: сдвинуть вправо за пределы экрана */
            transform: translateX(100%); 
            transition: transform 0.3s ease; 
            z-index: 50; /* Должен быть поверх всего */
            
            /* Ширина */
            width: 100%; 
            max-width: 320px; /* Дефолт для мобильных */
            
            /* Flexbox для распределения контента */
            display: flex;
            flex-direction: column;
        }
        @media (min-width: 768px) {
            #historyPanel {
                width: 400px; /* Шире на десктопе */
                max-width: none;
            }
        }
        
        /* Контейнер контента, занимающий оставшееся место */
        #historyContent {
            flex-grow: 1; /* Растягиваем, чтобы занять доступное пространство */
            overflow-y: auto; /* Прокрутка только внутри контента */
            padding-bottom: 2rem; /* Дополнительный отступ снизу */
        }
        
        /* Кастомный Scrollbar */
        #historyContent::-webkit-scrollbar {
            width: 8px;
        }

        #historyContent::-webkit-scrollbar-track {
            background: var(--color-bg-medium);
            border-radius: 10px;
        }

        #historyContent::-webkit-scrollbar-thumb {
            background: var(--color-accent-primary);
            border-radius: 10px;
            /* Обводка для лучшего контраста между ползунком и треком */
            border: 2px solid var(--color-bg-darkest); 
        }

        #historyContent::-webkit-scrollbar-thumb:hover {
            background: var(--color-accent-secondary);
        }
    </style>
</head>
<body class="min-h-screen dark-theme">
    
    <!-- Инициализация Firebase (сохранена для совместимости) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        if (firebaseConfig) {
            try {
                const app = initializeApp(firebaseConfig);
                const auth = getAuth(app);
                getFirestore(app);

                async function authenticate() {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("[Firebase] Ошибка аутентификации:", error);
                    }
                }
                authenticate();
            } catch (e) {
                console.error("[Firebase] Критическая ошибка инициализации:", e);
            }
        }
    </script>
    
    <!-- 1. Header Bar: Использует var(--color-bg-darkest) -->
    <header id="header" class="fixed top-0 left-0 right-0 z-50 p-4 shadow-xl text-white transition-colors duration-300" style="background-color: var(--color-bg-darkest);">
        <div class="flex justify-between items-center max-w-7xl mx-auto">
            <h1 id="headerTitle" class="text-xl font-bold tracking-wider" style="color: var(--color-text-primary);">Архив сюжета Houkai Gakuen 2</h1>
            
            <div class="flex items-center space-x-4">
                 <!-- Кнопка Истории -->
                <button id="historyToggle" onclick="toggleHistory()" class="px-3 py-1 text-sm rounded-full transition duration-150" style="background-color: var(--color-bg-medium); color: var(--color-text-primary);">
                    <span id="historyText">История</span>
                </button>
                
                <!-- Кнопка смены темы -->
                <button id="themeToggle" onclick="toggleTheme()" class="px-3 py-1 text-sm rounded-full transition duration-150" style="background-color: var(--color-bg-medium); color: var(--color-text-primary);">
                    <span id="themeIcon">🌙</span> <span id="themeText">Тёмная</span>
                </button>

                <!-- Кнопка сброса -->
                <button id="resetButton" onclick="resetProgress()" class="px-3 py-1 reset-button rounded-full transition duration-150 text-sm">Сброс</button>
                
                <!-- Выбор языка (Удален класс text-white) -->
                <select id="languageSelect" onchange="initializeOrUpdateUI(true)" class="select-field rounded-lg p-2 cursor-pointer transition hover:ring-2" style="background-color: var(--color-bg-medium);">
                    <option value="ru">Русский</option>
                    <option value="en">English</option>
                    <option value="zh">中文 (Chinese)</option>
                </select>
            </div>
        </div>
    </header>
    
    <!-- Панель Истории Диалогов (ПЕРЕМЕЩЕНА ВПРАВО) -->
    <div id="historyPanel" class="fixed top-0 h-full z-50 p-4 pt-20 shadow-2xl transition-transform duration-300" 
        style="background-color: var(--color-bg-darkest); opacity: 0.95;">
        <h2 id="historyTitle" class="text-xl font-bold mb-4" style="color: var(--color-text-primary);">История Диалогов</h2>
        <!-- historyContent теперь flex-grow: 1 и отвечает за прокрутку -->
        <div id="historyContent" class="space-y-3" style="height: calc(100% - 3.5rem);">
            <!-- History items here -->
        </div>
        <!-- Кнопка закрытия истории -->
        <button onclick="toggleHistory()" class="absolute top-4 right-4 text-xl p-2 rounded-full hover:bg-gray-700 transition" style="color: var(--color-text-primary);">
            &times;
        </button>
    </div>

    <!-- 2. Main Content Area -->
    <main class="pt-20 pb-4 px-4 max-w-7xl mx-auto min-h-screen">
        
        <!-- Controls Panel: Использует var(--color-bg-medium) -->
        <div class="control-panel p-4 rounded-xl shadow-lg mb-6 flex flex-wrap gap-4 items-end transition-colors duration-300">
            <!-- 1. Выбор Типа Сюжета -->
            <div class="flex-1 min-w-[180px]">
                <label for="storyTypeSelect" id="labelStoryType" class="block text-sm font-medium mb-1" style="color: var(--color-text-secondary);">Тип сюжета</label>
                <!-- Select: Использует var(--color-bg-main) -->
                <select id="storyTypeSelect" onchange="initializeOrUpdateUI(true)" class="select-field w-full rounded-lg p-2.5 cursor-pointer focus:ring-4 transition" style="background-color: var(--color-bg-main);">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- 2. Выбор Арки (НОВЫЙ ЭЛЕМЕНТ) -->
            <div id="arcSelectContainer" class="flex-1 min-w-[250px] hidden">
                <label for="arcSelect" id="labelArc" class="block text-sm font-medium mb-1" style="color: var(--color-text-secondary);">Арка</label>
                <select id="arcSelect" onchange="updateChapterSelect(); saveProgress()" class="select-field w-full rounded-lg p-2.5 cursor-pointer focus:ring-4 transition" disabled style="background-color: var(--color-bg-main);">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <!-- 3. Выбор Главы -->
            <div class="flex-1 min-w-[250px]">
                <label for="chapterSelect" id="labelChapter" class="block text-sm font-medium mb-1" style="color: var(--color-text-secondary);">Сюжет (Глава)</label>
                <!-- Select: Использует var(--color-bg-main) -->
                <select id="chapterSelect" onchange="enableLoadButton(); saveProgress()" class="select-field w-full rounded-lg p-2.5 cursor-pointer focus:ring-4 transition" disabled style="background-color: var(--color-bg-main);">
                    <!-- Options populated by JS -->
                </select>
            </div>
            
            <!-- Кнопка загрузки -->
            <button id="loadButton" onclick="updateStoryContent(0)" class="min-w-[120px] load-button text-white font-bold py-2.5 px-4 rounded-lg shadow-md transition duration-150 disabled:opacity-50" disabled>
                <span id="loadText">Загрузить</span>
            </button>
        </div>

        <!-- 3. Visual Novel Viewer (Main View) -->
        <!-- Фон вьювера: Использует var(--color-bg-main) -->
        <div id="vnViewer" class="relative w-full aspect-[16/9] rounded-xl shadow-2xl overflow-hidden flex flex-col justify-end transition-colors duration-500 cursor-pointer" 
            style="min-height: 400px; background-color: var(--color-bg-main);"
            onclick="navigateDialogue(1)"> 
            
            <!-- Background Layers Container (для кросс-фейда) -->
            <div id="backgroundContainer" class="absolute inset-0 z-0">
                <div id="bgLayer1" class="absolute inset-0 bg-layer opacity-100"></div>
                <div id="bgLayer2" class="absolute inset-0 bg-layer opacity-0"></div>
            </div>

            <!-- Sprite Container: Привязка bottom: 0 работает корректно -->
            <div id="spriteContainer" class="absolute inset-0 z-10 pointer-events-none flex justify-center items-end p-4">
                
                <div id="spriteLeftContainer" class="sprite-position left hidden">
                    <img id="spriteLeft" class="sprite-image" src="" alt="Левый персонаж" ondragstart="return false;">
                </div>
                
                <div id="spriteRightContainer" class="sprite-position right hidden">
                    <img id="spriteRight" class="sprite-image" src="" alt="Правый персонаж" ondragstart="return false;">
                </div>
            </div>

            <!-- Dialogue Wrapper -->
            <div id="dialogueWrapper" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 transition-all duration-300 opacity-100 hidden">
                
                <!-- Speaker Name Container -->
                <div id="speakerNameContainer" class="text-left mb-0 ml-8"> 
                    <div id="currentSpeaker" class="speaker-name rounded-t-lg rounded-b-none"></div>
                </div>
                
                <!-- Dialogue Text Content Box -->
                <div id="dialogueContentBox" 
                    class="vn-overlay w-[900px] h-[200px] p-8 flex items-start justify-start text-left rounded-xl shadow-2xl overflow-hidden"> 
                    <p id="currentText" class="text-xl leading-tight transition-opacity duration-300">Текст диалога...</p>
                </div>
            </div>
            
            <!-- Alert/Error Message Box -->
            <div id="alertMessage" class="absolute top-4 right-4 bg-red-600 alert-message text-white p-3 rounded-lg shadow-lg hidden z-30 transition-opacity duration-300 max-w-sm">
                Сообщение об ошибке.
            </div>
        </div>
    </main>

    <script>
        // ====================================================================
        // === КОНФИГУРАЦИЯ И ДАННЫЕ ===
        // ====================================================================
        
        const CONFIG = {
            PATHS: {
                SPRITE_BASE: 'images/sprites/',
                BACKGROUND_BASE: 'images/background/',
                METADATA_FILE: 'story/story_metadata.json', 
                STORY_BASE: 'story/', 
            },
            STORAGE: {
                KEY: 'vn_story_progress_v6', // Обновлен ключ для сохранения новой структуры
                THEME_KEY: 'vn_theme',
            },
            BACKOFF: {
                INITIAL_DELAY_MS: 750,  
                MAX_DELAY_MS: 7500,     
                MAX_ATTEMPTS: 3,        
            },
            PLACEHOLDERS: {
                DEFAULT_BG_COLOR: '#1f2937', 
            }
        };

        const STORY_GROUPS = {
            main: { 
                ru: "Основной сюжет", 
                en: "Main Story", 
                zh: "主线故事", 
                // Префиксы арк, не используем префикс для самой 'main'
                arcs: { 
                    retrospect: { ru: "Ретроспектр", en: "Retrospect", zh: "追溯篇", prefix: "re" },       // re
                    legacy: { ru: "Наследие", en: "Inheritance", zh: "传承篇", prefix: "in" },           // in
                    moth: { ru: "Огненный Мотылёк", en: "Fire Moth", zh: "逐火之蛾", prefix: "fm" },  // fm
                    new_start: { ru: "Новое начало", en: "New Start", zh: "新生篇", prefix: "nb" }, // nb
                    academy: { ru: "Академия Хоукая", en: "Houkai Academy", zh: "崩坏学园篇", prefix: "ha" }, // ha
                }
            },
            extra: { ru: "Дополнительный сюжет", en: "Extra Story", zh: "额外故事", prefix: "extra_" },
            bosses: { ru: "Боссы", en: "Boss", zh: "Boss", prefix: "boss_" },
            vn: { ru: "Визуальная новелла", en: "Visual Novel", zh: "视觉小说", prefix: "vn_" },
            romance: { ru: "Роман", en: "Romance", zh: "浪漫", prefix: "ln_" }
        };
        
        let currentDialogue = []; 
        let currentDialogueIndex = 0;
        let dialogueIsLoaded = false;
        let currentBackgroundUrl = null; 
        window.storyMetadata = null; 
        let isHistoryVisible = false; 
        let activeBgLayer = 1; // 1 или 2

        // Глобальные переменные для отслеживания текущего спрайтов
        let currentLeftSpriteFile = null;
        let currentRightSpriteFile = null;
        
        // Переводы UI
        const i18n = {
            ru: {
                headerTitle: "Архив сюжета Houkai Gakuen 2", labelStoryType: "Тип сюжета", labelArc: "Арка", labelChapter: "Сюжет (Глава)",
                loadText: "Загрузить", resetProgress: "Сброс", endOfStory: "История закончилась!",
                startOfStory: "Это начало истории.", placeholderMetadata: "--- Метаданные не загружены ---",
                errorFetchMetadataStrict: "Критическая ошибка: не удалось загрузить метаданные глав. Файл story/story_metadata.json отсутствует или недоступен.",
                errorChapterNotFound: "Файл главы не найден.",
                themeDark: "Тёмная", themeLight: "Светлая",
                historyTitle: "История Диалогов", historyButton: "История", historyEmpty: "История пуста.",
                selectArcPlaceholder: "--- Выберите арку ---",
                selectChapterPlaceholder: "--- Выберите главу ---",
            },
            en: {
                headerTitle: "VN Story Archive", labelStoryType: "Story Type", labelArc: "Arc", labelChapter: "Chapter",
                loadText: "Load", resetProgress: "Reset", endOfStory: "Story finished!",
                startOfStory: "This is the start of the story.", placeholderMetadata: "--- Metadata not loaded ---",
                errorFetchMetadataStrict: "Critical Error: Failed to load chapter metadata. The file story/story_metadata.json is missing or inaccessible.",
                errorChapterNotFound: "Chapter file not found.",
                themeDark: "Dark", themeLight: "Light",
                historyTitle: "Dialogue History", historyButton: "History", historyEmpty: "History is empty.",
                selectArcPlaceholder: "--- Select Arc ---",
                selectChapterPlaceholder: "--- Select Chapter ---",
            },
            zh: {
                headerTitle: "视觉小说故事档案", labelStoryType: "故事类型", labelArc: "篇章", labelChapter: "章节",
                loadText: "加载", resetProgress: "重置", endOfStory: "故事结束了!",
                startOfStory: "这是故事的开始。", placeholderMetadata: "--- 未加载元数据 ---",
                errorFetchMetadataStrict: "致命错误：无法加载章节元数据。文件 story/story_metadata.json 缺失或无法访问。",
                errorChapterNotFound: "未找到章节文件。",
                themeDark: "深色", themeLight: "浅色",
                historyTitle: "对话历史", historyButton: "History", historyEmpty: "历史为空。",
                selectArcPlaceholder: "--- 选择篇章 ---",
                selectChapterPlaceholder: "--- 选择章节 ---",
            }
        };

        // Кэшированные ссылки на элементы DOM
        let elements = {};

        // ====================================================================
        // === УПРАВЛЕНИЕ ТЕМАМИ ===
        // ====================================================================

        function saveTheme(theme) {
            localStorage.setItem(CONFIG.STORAGE.THEME_KEY, theme);
            applyTheme(theme);
        }

        function applyTheme(theme) {
            const lang = elements.languageSelect.value;
            const isDark = theme === 'dark';
            
            document.body.classList.toggle('light-theme', !isDark);
            document.body.classList.toggle('dark-theme', isDark);

            if (elements.themeIcon && elements.themeText) {
                elements.themeIcon.textContent = isDark ? '🌙' : '☀️';
                elements.themeText.textContent = isDark ? i18n[lang].themeDark : i18n[lang].themeLight;
            }
            
            // Если фон сейчас цветной (не картинка), нужно обновить цвет, используя переменную
            if (currentBackgroundUrl === CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR) {
                 // Получаем цвет фона из CSS-переменной
                 const themeBgColor = getComputedStyle(document.body).getPropertyValue('--color-bg-main').trim();
                 
                 const activeLayer = activeBgLayer === 1 ? elements.bgLayer1 : elements.bgLayer2;
                 const inactiveLayer = activeBgLayer === 1 ? elements.bgLayer2 : elements.bgLayer1;

                 activeLayer.style.backgroundColor = themeBgColor;
                 inactiveLayer.style.backgroundColor = themeBgColor;
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            saveTheme(newTheme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem(CONFIG.STORAGE.THEME_KEY) || 'dark';
            applyTheme(savedTheme);
        }

        // ====================================================================
        // === ИНИЦИАЛИЗАЦИЯ ===
        // ====================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            // Кэширование всех необходимых элементов DOM
            elements.languageSelect = document.getElementById('languageSelect');
            elements.storyTypeSelect = document.getElementById('storyTypeSelect');
            
            // Новые элементы для Арки
            elements.arcSelectContainer = document.getElementById('arcSelectContainer');
            elements.arcSelect = document.getElementById('arcSelect');
            
            elements.chapterSelect = document.getElementById('chapterSelect');
            elements.loadButton = document.getElementById('loadButton');
            elements.loadText = document.getElementById('loadText');
            elements.vnViewerElement = document.getElementById('vnViewer');
            elements.dialogueWrapper = document.getElementById('dialogueWrapper');
            elements.spriteLeftContainer = document.getElementById('spriteLeftContainer');
            elements.spriteRightContainer = document.getElementById('spriteRightContainer');
            elements.spriteLeftElement = document.getElementById('spriteLeft');
            elements.spriteRightElement = document.getElementById('spriteRight');
            elements.currentSpeaker = document.getElementById('currentSpeaker');
            elements.currentText = document.getElementById('currentText');
            elements.speakerNameContainer = document.getElementById('speakerNameContainer');
            elements.bgLayer1 = document.getElementById('bgLayer1');
            elements.bgLayer2 = document.getElementById('bgLayer2');
            elements.themeIcon = document.getElementById('themeIcon');
            elements.themeText = document.getElementById('themeText');
            elements.alertMessage = document.getElementById('alertMessage');
            
            // Элементы истории
            elements.historyPanel = document.getElementById('historyPanel');
            elements.historyContent = document.getElementById('historyContent');
            elements.historyTitle = document.getElementById('historyTitle');
            elements.historyButton = document.getElementById('historyToggle');
            elements.historyText = document.getElementById('historyText');


            // Установка дефолтного фона на активный слой (цвет)
            elements.bgLayer1.style.backgroundColor = CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR;
            elements.bgLayer1.style.backgroundImage = 'none';
            currentBackgroundUrl = CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR; 
            
            loadTheme(); // Загрузка и применение темы перед загрузкой прогресса
            loadProgress(); 
        });

        // ====================================================================
        // === CORE FUNCTIONS ===
        // ====================================================================
        
        /** Вспомогательная функция для выполнения асинхронных запросов с экспоненциальным отступом. */
        async function fetchWithBackoff(url) {
            for (let attempt = 0; attempt < CONFIG.BACKOFF.MAX_ATTEMPTS; attempt++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        // Если статус 404, не повторяем, так как файл отсутствует
                        if (response.status === 404) throw new Error(`404: File not found at ${url}`);
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (attempt === CONFIG.BACKOFF.MAX_ATTEMPTS - 1) throw error;
                    
                    const delay = Math.min(CONFIG.BACKOFF.INITIAL_DELAY_MS * (2 ** attempt), CONFIG.BACKOFF.MAX_DELAY_MS);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        /** Асинхронно загружает метаданные глав. */
        async function fetchChapterMetadata() {
            try {
                const response = await fetchWithBackoff(CONFIG.PATHS.METADATA_FILE); 
                window.storyMetadata = await response.json();
                
                // Инициализация UI после успешной загрузки метаданных
                populateSelects();
                const savedProgress = loadProgress(true);
                if (savedProgress) {
                    // Если есть сохраненный прогресс, обновляем селекты, чтобы соответствовать ему
                    updateSelectsFromProgress(savedProgress);
                } else {
                    // Иначе просто обновляем UI по дефолту
                    updateArcSelect();
                    updateChapterSelect();
                }

            } catch (error) {
                console.error(`[Metadata] Критическая ошибка загрузки внешнего файла.`, error);
                alertMessage(i18n[elements.languageSelect.value].errorFetchMetadataStrict); 
                window.storyMetadata = null; 
            }
        }

        /** Очищает имя файла, удаляя любой известный префикс. (ИСПРАВЛЕНИЕ БАГА) */
        function cleanFileName(fileName) {
            let cleaned = fileName;
            
            // Проверяем все известные префиксы (группы и арки)
            const allPrefixes = [];
            for (const typeKey in STORY_GROUPS) {
                const group = STORY_GROUPS[typeKey];
                if (group.prefix) {
                    allPrefixes.push(group.prefix);
                }
                if (group.arcs) {
                    for (const arcKey in group.arcs) {
                        allPrefixes.push(group.arcs[arcKey].prefix);
                    }
                }
            }
            
            // Удаляем префикс, если он есть в начале (от самого длинного к короткому, чтобы избежать ошибок)
            allPrefixes.sort((a, b) => b.length - a.length);

            for (const p of allPrefixes) {
                if (cleaned.startsWith(p)) {
                    // Удаляем только один раз, чтобы избежать удаления префикса из реального имени файла
                    cleaned = cleaned.substring(p.length);
                    // Возвращаемся, чтобы не пытаться удалить более короткий префикс, если был удален более длинный
                    return cleaned; 
                }
            }
            return cleaned;
        }

        /** Определяет полный путь к файлу главы, исправляя проблему дублирования префиксов. */
        function getStoryFilePath(storyType, arcKey, chapterFile) {
            // 1. Очищаем имя файла от потенциально дублирующихся префиксов
            const baseFileName = cleanFileName(chapterFile);
            
            let path = CONFIG.PATHS.STORY_BASE;
            let selectedPrefix = '';

            const prefixObj = STORY_GROUPS[storyType];
            
            if (storyType === 'main' && arcKey && prefixObj?.arcs && prefixObj.arcs[arcKey]) {
                // Основной сюжет использует префикс арки (например, 're')
                selectedPrefix = prefixObj.arcs[arcKey].prefix;
            } else if (prefixObj?.prefix) {
                // Остальные типы сюжета используют свой префикс (например, 'extra_')
                selectedPrefix = prefixObj.prefix;
            }

            // 2. Формируем окончательный путь: story/ + prefix + basefilename
            return path + selectedPrefix + baseFileName;
        }

        /** Асинхронно загружает данные сюжета по выбранному пути. */
        async function fetchStoryData() {
            const storyType = elements.storyTypeSelect.value;
            const arcKey = elements.arcSelect.value;
            const chapterFile = elements.chapterSelect.value;
            const lang = elements.languageSelect.value;

            if (!storyType || !chapterFile) return;

            const finalPath = getStoryFilePath(storyType, arcKey, chapterFile);

            elements.loadButton.disabled = true;
            elements.loadText.textContent = 'Загрузка...';

            try {
                const response = await fetchWithBackoff(finalPath);
                currentDialogue = await response.json();
                dialogueIsLoaded = true;
                currentDialogueIndex = 0; // Начинаем с первой строки
                clearHistory();
                renderDialogueStep();
                alertMessage(`Загружена глава: ${elements.chapterSelect.options[elements.chapterSelect.selectedIndex].textContent}`, 4000);
            } catch (error) {
                console.error(`[Story Load] Ошибка загрузки главы: ${finalPath}`, error);
                alertMessage(`${i18n[lang].errorChapterNotFound} (${finalPath})`, 6000);
                currentDialogue = [];
                dialogueIsLoaded = false;
                // Сброс сцены при ошибке
                resetScene();
            } finally {
                elements.loadButton.disabled = false;
                elements.loadText.textContent = i18n[lang].loadText;
                saveProgress(); // Сохраняем выбранную главу, даже если загрузка не удалась
            }
        }
        
        /** Обновляет контент сцены и диалога на текущем шаге. */
        function renderDialogueStep() {
            if (!dialogueIsLoaded || currentDialogue.length === 0) {
                resetScene();
                return;
            }

            const step = currentDialogue[currentDialogueIndex];
            if (!step) return;

            // 1. Обновление фона
            if (step.bg && step.bg !== currentBackgroundUrl) {
                crossFadeBackground(step.bg);
            } else if (!step.bg && !currentBackgroundUrl) {
                 // Если нет фона, устанавливаем дефолтный цвет
                 crossFadeBackground(CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR);
            }

            // 2. Обновление спрайтов
            updateSprites(step.sprite_left, step.sprite_right, step.speaker);

            // 3. Обновление диалога
            const speaker = step.speaker || '';
            const text = step.text || '...';

            elements.currentSpeaker.textContent = speaker;
            elements.currentText.textContent = text;
            elements.dialogueWrapper.classList.remove('hidden');

            // Позиционирование имени спикера
            if (speaker) {
                elements.speakerNameContainer.classList.remove('hidden');
                // Устанавливаем позицию спикера относительно активного спрайта
                const activeSpritePosition = speaker === currentLeftSpriteFile ? 'left' : speaker === currentRightSpriteFile ? 'right' : 'center';

                // Сброс классов позиционирования
                elements.speakerNameContainer.classList.remove('ml-8', 'mr-8', 'text-left', 'text-right');
                
                // Простая эмуляция привязки к активному спрайту
                if (currentLeftSpriteFile && speaker === currentLeftSpriteFile) {
                    elements.speakerNameContainer.classList.add('ml-8', 'text-left'); // Левый
                } else if (currentRightSpriteFile && speaker === currentRightSpriteFile) {
                    elements.speakerNameContainer.classList.add('mr-8', 'text-right'); // Правый
                } else {
                    elements.speakerNameContainer.classList.add('ml-8', 'text-left'); // Дефолт слева для Narrator/других
                }
            } else {
                elements.speakerNameContainer.classList.add('hidden');
            }
            
            // 4. Добавление в историю
            addHistoryEntry(speaker, text, currentDialogueIndex);
        }

        /** Переключает фон, используя технику кросс-фейда. */
        function crossFadeBackground(newBgFileName) {
            // Если newBgFileName - это цвет, используем его, иначе строим URL
            let finalBgUrl = newBgFileName;
            let isColor = false;
            
            if (newBgFileName.startsWith('#')) {
                isColor = true;
            } else {
                const encodedBgFileName = encodeURIComponent(newBgFileName);
                finalBgUrl = `url(${CONFIG.PATHS.BACKGROUND_BASE}${encodedBgFileName})`;
            }
            
            if (finalBgUrl === currentBackgroundUrl && !isColor) return; // Не менять, если это та же картинка

            const { bgLayer1, bgLayer2 } = elements;

            const nextLayer = activeBgLayer === 1 ? bgLayer2 : bgLayer1;
            const currentLayer = activeBgLayer === 1 ? bgLayer1 : bgLayer2;
            
            // Подготовка следующего слоя
            if (isColor) {
                nextLayer.style.backgroundImage = 'none';
                nextLayer.style.backgroundColor = finalBgUrl; // Цвет
            } else {
                nextLayer.style.backgroundColor = 'transparent';
                nextLayer.style.backgroundImage = finalBgUrl; // URL
            }

            // Переключение слоев:
            currentLayer.style.opacity = 0;
            nextLayer.style.opacity = 1;

            // Обновление состояния
            activeBgLayer = activeBgLayer === 1 ? 2 : 1;
            currentBackgroundUrl = isColor ? CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR : finalBgUrl;

             // Если newBgFileName - это цвет, обновляем глобальную переменную, чтобы при смене темы обновить цвет
            if (isColor) {
                currentBackgroundUrl = CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR;
            }
        }
        
        /** Обновляет изображения и состояние затемнения спрайтов. */
        function updateSprites(leftSpriteFile, rightSpriteFile, activeSpeaker) {
            
            const { spriteLeftElement, spriteRightElement, spriteLeftContainer, spriteRightContainer } = elements;

            // --- ОБНОВЛЕНИЕ ЛЕВОГО СПРАЙТА ---
            if (leftSpriteFile !== currentLeftSpriteFile) {
                const url = spritePath(leftSpriteFile);
                loadSprite(url, spriteLeftElement, spriteLeftContainer);
                currentLeftSpriteFile = leftSpriteFile;
            }
            
            // --- ОБНОВЛЕНИЕ ПРАВОГО СПРАЙТА ---
            if (rightSpriteFile !== currentRightSpriteFile) {
                const url = spritePath(rightSpriteFile);
                loadSprite(url, spriteRightElement, spriteRightContainer);
                currentRightSpriteFile = rightSpriteFile;
            }

            // --- ЛОГИКА ЗАТЕМНЕНИЯ/ОСВЕТЛЕНИЯ (ИСПРАВЛЕНИЕ) ---
            const leftDimmed = !!currentLeftSpriteFile && activeSpeaker && activeSpeaker !== currentLeftSpriteFile;
            const rightDimmed = !!currentRightSpriteFile && activeSpeaker && activeSpeaker !== currentRightSpriteFile;
            
            // Затемняем спрайт, если он не говорит
            spriteLeftElement.classList.toggle('dimmed-sprite', leftDimmed);
            spriteRightElement.classList.toggle('dimmed-sprite', rightDimmed);
        }


        /** Переходит к следующему или предыдущему шагу диалога. */
        function navigateDialogue(direction) {
            if (!dialogueIsLoaded || currentDialogue.length === 0) return;
            
            const newIndex = currentDialogueIndex + direction;
            const lang = elements.languageSelect.value;

            if (newIndex >= 0 && newIndex < currentDialogue.length) {
                currentDialogueIndex = newIndex;
                renderDialogueStep();
                saveProgress();
            } else if (newIndex >= currentDialogue.length) {
                alertMessage(i18n[lang].endOfStory);
                currentDialogueIndex = currentDialogue.length - 1;
                saveProgress();
            } else {
                alertMessage(i18n[lang].startOfStory);
            }
        }
        
        /** Определяет путь/URL к спрайту. */
        const spritePath = (fileName) => {
            if (!fileName) return null;
            const encodedFileName = encodeURIComponent(fileName);
            return CONFIG.PATHS.SPRITE_BASE + encodedFileName; 
        };
        
        /**
         * Загружает изображение спрайта и плавно его отображает, сохраняя его в сцене.
         */
        function loadSprite(url, element, container) {
            
            if (!url) {
                // Если URL пуст, скрываем спрайт и удаляем его из сцены
                container.classList.add('hidden');
                element.src = '';
                return;
            }
            
            const tempImg = new Image();
            
            tempImg.onload = () => {
                element.src = tempImg.src; 
                container.classList.remove('hidden'); 
            };
            
            tempImg.onerror = () => {
                container.classList.add('hidden');
                console.warn(`[Sprite Load] Не удалось загрузить спрайт: ${url}.`);
                element.src = '';
            };

            const finalUrl = `${url}?t=${Date.now()}`;
            tempImg.src = finalUrl;
        }

        /** Сброс сцены (диалог, спрайты, фон) */
        function resetScene() {
            elements.dialogueWrapper.classList.add('hidden');
            elements.currentSpeaker.textContent = '';
            elements.currentText.textContent = i18n[elements.languageSelect.value].placeholderMetadata;

            // Сброс спрайтов
            updateSprites(null, null, null);
            currentLeftSpriteFile = null;
            currentRightSpriteFile = null;

            // Сброс фона на дефолтный цвет
            crossFadeBackground(CONFIG.PLACEHOLDERS.DEFAULT_BG_COLOR);
            dialogueIsLoaded = false;
        }
        
        /** Асинхронно обновляет контент, начиная с шага 0. */
        function updateStoryContent() {
            fetchStoryData();
        }

        // ====================================================================
        // === UI UTILITIES (Selects, Alerts) ===
        // ====================================================================

        /** Заполняет селекты Story Type */
        function populateStoryTypeSelect() {
            const select = elements.storyTypeSelect;
            select.innerHTML = '';
            const lang = elements.languageSelect.value;

            for (const key in STORY_GROUPS) {
                const option = document.createElement('option');
                option.value = key;
                // Используем ключ языка для отображаемого текста
                option.textContent = STORY_GROUPS[key][lang] || key;
                select.appendChild(option);
            }

            // Устанавливаем значение по умолчанию, если оно не было загружено из прогресса
            if (select.value === "") {
                select.value = 'main'; 
            }
        }
        
        /** Обновляет селект Арки на основе выбранного Story Type. */
        function updateArcSelect() {
            const storyType = elements.storyTypeSelect.value;
            const select = elements.arcSelect;
            const container = elements.arcSelectContainer;
            const lang = elements.languageSelect.value;
            const metadata = window.storyMetadata ? window.storyMetadata[storyType] : null;

            // Если это 'main' или другой тип с арками (arcs), показываем контейнер
            const hasArcs = storyType === 'main' && STORY_GROUPS.main.arcs; 
            
            if (hasArcs) {
                container.classList.remove('hidden');
                select.innerHTML = `<option value="" disabled selected>${i18n[lang].selectArcPlaceholder}</option>`;
                select.disabled = true;

                if (metadata && STORY_GROUPS.main.arcs) {
                    select.disabled = false;
                    for (const arcKey in STORY_GROUPS.main.arcs) {
                        // Проверяем, есть ли главы для этой арки в метаданных
                        if (metadata[arcKey] && Object.keys(metadata[arcKey]).length > 0) { 
                             const option = document.createElement('option');
                             option.value = arcKey;
                             option.textContent = STORY_GROUPS.main.arcs[arcKey][lang] || arcKey;
                             select.appendChild(option);
                        }
                    }
                }
            } else {
                container.classList.add('hidden');
                select.innerHTML = '';
                select.disabled = true;
            }
        }

        /** Обновляет селект Главы на основе выбранного Story Type и Арки. */
        function updateChapterSelect() {
            const storyType = elements.storyTypeSelect.value;
            const arcKey = elements.arcSelect.value;
            const select = elements.chapterSelect;
            const lang = elements.languageSelect.value;
            
            select.innerHTML = `<option value="" disabled selected>${i18n[lang].selectChapterPlaceholder}</option>`;
            select.disabled = true;
            elements.loadButton.disabled = true;

            if (!window.storyMetadata || !storyType) return;
            
            let chapters = {};

            if (storyType === 'main' && arcKey) {
                // Для "main" используем метаданные арки
                chapters = window.storyMetadata[storyType]?.[arcKey] || {};
            } else if (storyType !== 'main') {
                // Для остальных типов используем метаданные типа
                 chapters = window.storyMetadata[storyType] || {};
            }

            if (Object.keys(chapters).length > 0) {
                select.disabled = false;
                for (const file in chapters) {
                    const option = document.createElement('option');
                    option.value = file; // Имя файла (e.g., '01_prologue.json' или 'extra_01.json')
                    option.textContent = chapters[file][lang] || chapters[file].ru || file;
                    select.appendChild(option);
                }
            }
        }

        /** Обновляет все UI-элементы на основе текущего языка/прогресса. */
        function initializeOrUpdateUI(updateMetadataAndSelects = false) {
            const lang = elements.languageSelect.value;
            
            // 1. Обновление текста UI
            document.getElementById('headerTitle').textContent = i18n[lang].headerTitle;
            document.getElementById('labelStoryType').textContent = i18n[lang].labelStoryType;
            document.getElementById('labelArc').textContent = i18n[lang].labelArc;
            document.getElementById('labelChapter').textContent = i18n[lang].labelChapter;
            elements.loadText.textContent = i18n[lang].loadText;
            document.getElementById('resetButton').textContent = i18n[lang].resetProgress;
            elements.historyTitle.textContent = i18n[lang].historyTitle;
            elements.historyText.textContent = i18n[lang].historyButton;

            // Обновление темы (для текста кнопки)
            applyTheme(document.body.classList.contains('dark-theme') ? 'dark' : 'light');

            // 2. Обновление селектов
            if (updateMetadataAndSelects) {
                populateStoryTypeSelect();
                updateArcSelect();
                updateChapterSelect();
                saveProgress();
            }

            // 3. Обновление истории диалогов
            renderHistory();
            
            // Если диалог загружен, обновляем текущий шаг для смены языка
            if (dialogueIsLoaded) {
                 renderDialogueStep();
            } else {
                elements.currentText.textContent = i18n[lang].placeholderMetadata;
            }
        }
        
        /** Показывает временное сообщение об ошибке/уведомлении. */
        function alertMessage(message, duration = 3000) {
            const alertBox = elements.alertMessage;
            alertBox.textContent = message;
            alertBox.classList.remove('hidden', 'opacity-0');
            alertBox.classList.add('opacity-100');
            
            setTimeout(() => {
                alertBox.classList.remove('opacity-100');
                alertBox.classList.add('opacity-0');
                // Скрываем после перехода
                setTimeout(() => alertBox.classList.add('hidden'), 300);
            }, duration);
        }

        function enableLoadButton() {
            elements.loadButton.disabled = !elements.chapterSelect.value;
        }

        /** Заполняет все селекты после загрузки метаданных. */
        function populateSelects() {
            populateStoryTypeSelect();
        }

        // ====================================================================
        // === PROGRESS AND HISTORY ===
        // ====================================================================
        
        /** Сохраняет прогресс (выбранные селекты и текущий индекс диалога). */
        function saveProgress() {
            const progress = {
                storyType: elements.storyTypeSelect.value,
                arcKey: elements.arcSelect.value,
                chapterFile: elements.chapterSelect.value,
                dialogueIndex: currentDialogueIndex,
                language: elements.languageSelect.value,
            };
            localStorage.setItem(CONFIG.STORAGE.KEY, JSON.stringify(progress));
        }

        /** Загружает прогресс. */
        function loadProgress(onlyRead = false) {
            const saved = localStorage.getItem(CONFIG.STORAGE.KEY);
            if (!saved) return null;

            const progress = JSON.parse(saved);
            if (onlyRead) return progress;

            // Применяем загруженный прогресс к UI
            elements.languageSelect.value = progress.language || 'ru';
            initializeOrUpdateUI(false); // Обновляем UI по языку

            return progress;
        }
        
        /** Обновляет селекты, используя загруженный прогресс. */
        function updateSelectsFromProgress(progress) {
             // 1. Story Type
             if (progress.storyType) elements.storyTypeSelect.value = progress.storyType;

             // 2. Arc Select
             updateArcSelect(); // Заполняем список арок
             if (progress.arcKey) elements.arcSelect.value = progress.arcKey;

             // 3. Chapter Select
             updateChapterSelect(); // Заполняем список глав
             if (progress.chapterFile) elements.chapterSelect.value = progress.chapterFile;

             // 4. Load button state
             enableLoadButton();
             
             // 5. Dialogue index
             currentDialogueIndex = progress.dialogueIndex || 0;

             // Автоматическая загрузка, если выбрана глава
             if (progress.chapterFile) {
                // Если файл главы есть, пытаемся его загрузить с нужного индекса
                fetchStoryData().then(() => {
                    // После загрузки диалога, переходим к сохраненному шагу
                    if (currentDialogueIndex > 0) {
                        // Очистка истории, чтобы она не дублировалась при рендере
                        clearHistory(); 
                        for (let i = 0; i <= currentDialogueIndex; i++) {
                            const step = currentDialogue[i];
                            if(step) {
                                // Восстанавливаем историю до текущего шага
                                addHistoryEntry(step.speaker || '', step.text || '...', i, true); 
                            }
                        }
                    }
                    renderDialogueStep(); 
                });
             } else {
                resetScene();
             }
        }


        /** Сбрасывает прогресс и сцену. */
        function resetProgress() {
            if (!confirm(i18n[elements.languageSelect.value].resetProgress + "?")) return;
            localStorage.removeItem(CONFIG.STORAGE.KEY);
            currentDialogue = [];
            currentDialogueIndex = 0;
            dialogueIsLoaded = false;
            
            // Сброс селектов
            elements.storyTypeSelect.value = 'main';
            updateArcSelect();
            updateChapterSelect();
            
            resetScene();
            clearHistory();
            saveProgress();
        }

        // ====================================================================
        // === HISTORY PANEL ===
        // ====================================================================

        /** Переключает видимость панели истории. */
        function toggleHistory() {
            isHistoryVisible = !isHistoryVisible;
            elements.historyPanel.classList.toggle('open', isHistoryVisible);
        }

        /** Добавляет запись в историю (без рендера, только данные) */
        function addHistoryEntry(speaker, text, index, isRestoring = false) {
             // Если мы восстанавливаем историю, не добавляем дубликат
             if (isRestoring) {
                 // Если элемент истории уже есть, не добавляем
                 if (elements.historyContent.querySelector(`#history-item-${index}`)) return;
             } else {
                 // В обычном режиме, если мы переходим вперед, удаляем все последующие шаги
                 let lastIndex = elements.historyContent.children.length - 1;
                 while (lastIndex >= 0 && parseInt(elements.historyContent.children[lastIndex].dataset.index) > index) {
                     elements.historyContent.children[lastIndex].remove();
                     lastIndex--;
                 }
                 // Если мы просто обновили текущий шаг, удаляем старый
                 if (elements.historyContent.querySelector(`#history-item-${index}`)) {
                     elements.historyContent.querySelector(`#history-item-${index}`).remove();
                 }
             }

            const lang = elements.languageSelect.value;
            const item = document.createElement('div');
            item.id = `history-item-${index}`;
            item.dataset.index = index;
            item.className = `p-3 rounded-lg transition duration-150 cursor-pointer ${
                index === currentDialogueIndex ? 'shadow-md ring-2' : ''
            }`;
            item.style.backgroundColor = 'var(--color-bg-medium)';
            item.style.borderColor = index === currentDialogueIndex ? 'var(--color-accent-ring)' : 'transparent';
            item.onclick = () => {
                currentDialogueIndex = index;
                renderDialogueStep();
                saveProgress();
                // При клике обновляем только активный элемент
                renderHistory(); 
                toggleHistory();
            };

            const speakerSpan = document.createElement('span');
            speakerSpan.textContent = speaker ? speaker + ': ' : '';
            speakerSpan.className = 'font-bold';
            speakerSpan.style.color = 'var(--color-speaker-name)';

            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            textSpan.style.color = 'var(--color-text-primary)';

            item.appendChild(speakerSpan);
            item.appendChild(textSpan);
            
            // Вставляем элемент в конец
            elements.historyContent.appendChild(item);
            
            // Автоматическая прокрутка к последнему элементу только если это не восстановление
            if (!isRestoring) {
                elements.historyContent.scrollTop = elements.historyContent.scrollHeight;
            }

            // Обновляем текст, если история пуста
            if (elements.historyContent.children.length > 0) {
                 const placeholder = elements.historyContent.querySelector('.history-placeholder');
                 if (placeholder) placeholder.remove();
            } else {
                renderHistory();
            }

        }
        
        /** Очищает все записи истории. */
        function clearHistory() {
            elements.historyContent.innerHTML = '';
        }

        /** Перерисовывает панель истории (в основном для обновления активного класса и плейсхолдера) */
        function renderHistory() {
            const lang = elements.languageSelect.value;
            
            // Если история пуста, добавляем плейсхолдер
            if (elements.historyContent.children.length === 0) {
                 elements.historyContent.innerHTML = `<p class="history-placeholder text-center py-8" style="color: var(--color-text-secondary);">${i18n[lang].historyEmpty}</p>`;
                 return;
            }
            
            // Обновляем стили для активного элемента
            Array.from(elements.historyContent.children).forEach(item => {
                const index = parseInt(item.dataset.index);
                item.classList.remove('shadow-md', 'ring-2');
                item.style.borderColor = 'transparent';
                
                if (index === currentDialogueIndex) {
                    item.classList.add('shadow-md', 'ring-2');
                    item.style.borderColor = 'var(--color-accent-ring)';
                    // Прокрутка к активному элементу при рендере (если панель открыта)
                    if (isHistoryVisible) {
                        item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            });
        }


        // ====================================================================
        // === ЗАПУСК ===
        // ====================================================================

        // Запускаем загрузку метаданных, чтобы начать инициализацию UI
        fetchChapterMetadata();
    </script>
</body>
</html>
