<!-- Выбранная палитра: Темные нейтральные тона (Черный, Серый) с акцентами Honkai Red/Purple. -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Архив Сюжета ВН</title>
    <!-- Подключение Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #5c5c5c; /* Фон сайта */
            color: #e5e7eb;
            background-size: cover;
            background-position: center;
        }
        .vn-overlay {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
        }
        .speaker-name {
            background-color: #2a2a2a;
            color: #ca7cfe; /* Пурпурный акцент */
            padding: 4px 12px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: inline-block;
            font-weight: bold;
            font-size: 1.25rem;
        }
        /* Стили для спрайтов */
        .sprite-position {
            position: absolute;
            bottom: 0;
            /* Усиление: контейнер спрайта занимает почти всю высоту и 45% ширины */
            height: 95%; 
            width: 45%;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 10;
            display: flex; 
            justify-content: center;
            align-items: flex-end;
        }
        .sprite-position.left { left: 0; }
        .sprite-position.right { right: 0; }
        .sprite-image {
            /* КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Гарантируем, что изображение заполняет контейнер */
            height: 100%; 
            width: auto;
            max-height: 100%; 
            object-fit: contain;
            opacity: 1; 
            display: block; /* Убеждаемся, что это блочный элемент */
        }
        .dimmed-sprite {
            opacity: 0.4;
        }
    </style>
</head>
<body class="min-h-screen">
    
    <!-- Firebase Setup (Оставляем для совместимости с платформой) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Глобальные переменные, предоставленные средой
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = 'anon';

        if (firebaseConfig) {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                async function authenticate() {
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                        userId = auth.currentUser?.uid || 'anon-user';
                    } catch (error) {
                        console.error("[Firebase] Ошибка аутентификации:", error);
                    }
                }
                authenticate();
            } catch (e) {
                console.error("[Firebase] Критическая ошибка инициализации:", e);
            }
        }
    </script>
    
    <!-- 1. Header Bar -->
    <header id="header" class="fixed top-0 left-0 right-0 z-50 p-4 shadow-xl text-white" style="background-color: #2a2a2a;">
        <div class="flex justify-between items-center max-w-7xl mx-auto">
            <h1 id="headerTitle" class="text-xl font-bold tracking-wider">Архив Сюжета ВН</h1>
            
            <div class="flex items-center space-x-4">
                <button id="resetButton" onclick="resetProgress()" class="px-3 py-1 bg-red-800 hover:bg-red-700 rounded-full transition duration-150 text-sm">Сброс</button>
                <select id="languageSelect" onchange="initializeOrUpdateUI(true)" class="bg-gray-700 text-white rounded-lg p-2 cursor-pointer transition hover:ring-2 ring-red-400">
                    <option value="ru">Русский</option>
                    <option value="en">English</option>
                </select>
            </div>
        </div>
    </header>

    <!-- 2. Main Content Area -->
    <main class="pt-20 pb-4 px-4 max-w-7xl mx-auto min-h-screen">
        
        <!-- Controls Panel -->
        <div class="bg-gray-700 p-4 rounded-xl shadow-lg mb-6 flex flex-wrap gap-4 items-end">
            <div class="flex-1 min-w-[180px]">
                <label for="storyTypeSelect" id="labelStoryType" class="block text-sm font-medium mb-1 text-gray-300">Тип сюжета</label>
                <!-- Тип сюжета ВСЕГДА активен -->
                <select id="storyTypeSelect" onchange="initializeOrUpdateUI(true)" class="w-full bg-gray-800 text-white rounded-lg p-2.5 cursor-pointer focus:ring-red-400 focus:border-red-400 transition">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <div class="flex-1 min-w-[250px]">
                <label for="chapterSelect" id="labelChapter" class="block text-sm font-medium mb-1 text-gray-300">Сюжет (Глава)</label>
                <!-- Список глав отключается, если метаданные не загружены -->
                <select id="chapterSelect" onchange="enableLoadButton(); saveProgress()" class="w-full bg-gray-800 text-white rounded-lg p-2.5 cursor-pointer focus:ring-red-400 focus:border-red-400 transition" disabled>
                    <!-- Options populated by JS -->
                </select>
            </div>
            
            <button id="loadButton" onclick="updateStoryContent(0)" class="min-w-[120px] bg-red-600 hover:bg-red-700 text-white font-bold py-2.5 px-4 rounded-lg shadow-md transition duration-150 disabled:opacity-50" disabled>
                <span id="loadText">Загрузить</span>
            </button>
        </div>

        <!-- 3. Visual Novel Viewer (Main View) -->
        <div id="vnViewer" class="relative w-full aspect-[16/9] bg-gray-900 rounded-xl shadow-2xl overflow-hidden flex flex-col justify-end transition-colors duration-500 cursor-pointer" 
             style="min-height: 400px; background-size: cover; background-position: center;"
             onclick="navigateDialogue(1)"> 

            <!-- Sprite Container -->
            <div id="spriteContainer" class="absolute inset-0 z-10 pointer-events-none flex justify-center items-end p-4">
                
                <div id="spriteLeftContainer" class="sprite-position left hidden">
                    <img id="spriteLeft" class="sprite-image" src="" alt="Левый персонаж">
                </div>
                
                <div id="spriteRightContainer" class="sprite-position right hidden">
                    <img id="spriteRight" class="sprite-image" src="" alt="Правый персонаж">
                </div>
            </div>

            <!-- Dialogue Wrapper - Скрыт по умолчанию и пока не загружен контент -->
            <div id="dialogueWrapper" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 transition-all duration-300 opacity-100 hidden">
                
                <!-- Speaker Name Container -->
                <div id="speakerNameContainer" class="text-left mb-0 ml-8"> 
                    <div id="currentSpeaker" class="speaker-name rounded-t-lg rounded-b-none"></div>
                </div>
                
                <!-- Dialogue Text Content Box -->
                <div id="dialogueContentBox" 
                    class="vn-overlay w-[900px] h-[200px] p-8 flex items-start justify-start text-left rounded-xl shadow-2xl overflow-hidden"> 
                    <p id="currentText" class="text-xl leading-tight transition-opacity duration-300">Текст диалога...</p>
                </div>
            </div>
        </div>
    </main>

    <script>
        // ====================================================================
        // === КОНСТАНТЫ И ДАННЫЕ ===
        // ====================================================================
        
        // Базовые пути, указанные пользователем
        const SPRITE_BASE_PATH = 'images/sprites/';
        const BACKGROUND_BASE_PATH = 'images/background/';

        // Base64-кодированные SVG для надежных плейсхолдеров
        const KIANA_SPRITE_B64 = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjODAwMDgwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJJbnRlciIgZm9udC1zaXplPSI0MHB4IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5LSUFOQTwvdGV4dD48L3N2Zz4='; // Пурпурный
        const MEI_SPRITE_B64 = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjRkY1NzMzIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJJbnRlciIgZm9udC1zaXplPSI0MHB4IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5NRUk8L3RleHQ+PC9zdmc+'; // Красный
        const DEFAULT_SPRITE_B64 = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMjIyMjIyIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJJbnRlciIgZm9udC1zaXplPSI0MHB4IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5TUFJJSVQ8L3RleHQ+PC9zdmc+';
        const DEFAULT_BG_B64 = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiMyYjJkM2EiLz48L3N2Zz4='; // Темный фон без текста
        
        const STORAGE_KEY = 'vn_story_progress_v4';
        const METADATA_FILE = 'story/story_metadata.json'; 
        const STORY_BASE_PATH = 'story/'; 
        
        // Настройки повторной загрузки контента (Exponential Backoff)
        const INITIAL_DELAY_MS = 2000;
        const MAX_DELAY_MS = 30000;
        
        // Настройки постоянной загрузки изображений (спрайтов/фонов)
        const MAX_PERSISTENT_IMAGE_RETRIES = 50; 
        const PERSISTENT_IMAGE_RETRY_DELAY_MS = 2000; 

        // Группировка сюжетов (без изменений)
        const STORY_GROUPS = {
            main: { ru: "Основной сюжет", en: "Main Story", cn: "主线剧情", prefix: "main_" },
            extra: { ru: "Дополнительный сюжет", en: "Extra Story", cn: "额外剧情", prefix: "extra_" },
            bosses: { ru: "Боссы", en: "Boss Fights", cn: "首领战", prefix: "boss_" },
            vn: { ru: "Визуальная новелла", en: "Visual Novel", cn: "视觉小说", prefix: "vn_" },
            romance: { ru: "Роман", en: "Romance", cn: "Novel", prefix: "ln_" }
        };
        
        let currentDialogue = []; 
        let currentDialogueIndex = 0;
        let dialogueIsLoaded = false;
        
        // Переводы UI (без изменений)
        const i18n = {
            ru: {
                headerTitle: "Архив Сюжета ВН",
                labelStoryType: "Тип сюжета",
                labelChapter: "Сюжет (Глава)",
                loadText: "Загрузить",
                resetProgress: "Сброс",
                errorFetchMetadataStrict: "Критическая ошибка: не удалось загрузить метаданные глав. Файл story/story_metadata.json отсутствует или недоступен.",
                endOfStory: "История закончилась!",
                startOfStory: "Это начало истории.",
                placeholderMetadata: "--- Метаданные не загружены ---"
            },
            en: {
                headerTitle: "VN Story Archive",
                labelStoryType: "Story Type",
                labelChapter: "Chapter",
                loadText: "Load",
                resetProgress: "Reset",
                errorFetchMetadataStrict: "Critical Error: Failed to load chapter metadata. The file story/story_metadata.json is missing or inaccessible.",
                endOfStory: "Story finished!",
                startOfStory: "This is the start of the story.",
                placeholderMetadata: "--- Metadata not loaded ---"
            }
        };

        let spriteLeftContainer, spriteRightContainer;
        let spriteLeftElement, spriteRightElement;
        let vnViewerElement;
        window.storyMetadata = null; 

        // ====================================================================
        // === CORE FUNCTIONS ===
        // ====================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            spriteLeftContainer = document.getElementById('spriteLeftContainer');
            spriteRightContainer = document.getElementById('spriteRightContainer');
            spriteLeftElement = document.getElementById('spriteLeft');
            spriteRightElement = document.getElementById('spriteRight');
            vnViewerElement = document.getElementById('vnViewer');
            
            // Устанавливаем дефолтный фон сразу после загрузки DOM
            vnViewerElement.style.backgroundImage = `url('${DEFAULT_BG_B64}')`;

            loadProgress(); 
        });

        /** * Асинхронно загружает метаданные глав. */
        async function fetchChapterMetadata() {
            try {
                const response = await fetch(METADATA_FILE); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                window.storyMetadata = await response.json();
                console.log("[Metadata] Загрузка глав завершена.");
            } catch (error) {
                console.error(`[Metadata] Критическая ошибка загрузки внешнего файла (${METADATA_FILE}).`, error);
                alertMessage(i18n[document.getElementById('languageSelect').value].errorFetchMetadataStrict); 
                window.storyMetadata = null; 
            }
        }

        /** Переходит к следующему или предыдущему шагу диалога. */
        function navigateDialogue(direction) {
            if (!dialogueIsLoaded || currentDialogue.length === 0) return;
            
            const newIndex = currentDialogueIndex + direction;

            if (newIndex >= 0 && newIndex < currentDialogue.length) {
                currentDialogueIndex = newIndex;
                renderDialogueStep();
                saveProgress();
            } else if (newIndex >= currentDialogue.length) {
                alertMessage(i18n[document.getElementById('languageSelect').value].endOfStory);
                currentDialogueIndex = currentDialogue.length - 1;
                saveProgress();
            } else {
                alertMessage(i18n[document.getElementById('languageSelect').value].startOfStory);
            }
        }
        
        /** * Определяет путь/URL к спрайту. */
        const spritePath = (fileName) => {
            if (!fileName) return DEFAULT_SPRITE_B64;
            
            const lowerCaseName = fileName.toLowerCase();

            // Если это Base64-плейсхолдер
            if (lowerCaseName.includes('kiana')) return KIANA_SPRITE_B64;
            if (lowerCaseName.includes('mei')) return MEI_SPRITE_B64;
            
            // Если это не плейсхолдер, возвращаем имя файла
            return fileName; 
        };
        
        /** * Загружает ВНЕШНЕЕ изображение (или фон) с механизмом постоянного повтора. */
        function loadExternalImageWithPersistence(url, element, isBackground = false, attempt = 1) {
            // Если достигнут лимит попыток, останавливаемся
            if (attempt > MAX_PERSISTENT_IMAGE_RETRIES) {
                 console.error(`[Image Load] Достигнут лимит попыток (${MAX_PERSISTENT_IMAGE_RETRIES}) для ${url}. Загрузка прекращена.`);
                 if (!isBackground) element.parentElement.classList.add('hidden');
                 return;
            }
            
            console.log(`[Image Load] Попытка загрузки ВНЕШНЕГО URL: ${url} (Попытка ${attempt})`);


            // --- Логика для спрайтов (<img>) с внешним URL ---
            if (!isBackground) {
                // Очищаем обработчики перед новой попыткой
                element.onload = null;
                element.onerror = null;

                element.onload = () => {
                    console.log(`[Sprite Load] Успешно загружен: ${url} (Попытка ${attempt})`);
                };

                element.onerror = () => {
                    console.warn(`[Sprite Load] ОШИБКА: ${url}. Повтор через ${PERSISTENT_IMAGE_RETRY_DELAY_MS} мс.`);
                    // НЕ очищаем element.src здесь, так как это может вызвать CLS. 
                    // Просто ждем таймаута для следующей попытки.
                    setTimeout(() => loadExternalImageWithPersistence(url, element, isBackground, attempt + 1), PERSISTENT_IMAGE_RETRY_DELAY_MS);
                };
                
                // Добавляем параметр для обхода кеша
                const cacheBuster = attempt > 1 ? `?t=${Date.now()}` : '';
                element.src = url + cacheBuster;

            } else {
                // --- Логика для фона (CSS background-image) с внешним URL ---
                const tempImg = new Image();
                tempImg.onload = () => {
                    console.log(`[Background Load] Успешно загружен: ${url} (Попытка ${attempt})`);
                    element.style.backgroundImage = `url('${url}')`;
                };
                
                tempImg.onerror = () => {
                    console.warn(`[Background Load] ОШИБКА: ${url}. Повтор через ${PERSISTENT_IMAGE_RETRY_DELAY_MS} мс.`);
                    setTimeout(() => loadExternalImageWithPersistence(url, element, isBackground, attempt + 1), PERSISTENT_IMAGE_RETRY_DELAY_MS);
                };
                
                const cacheBuster = attempt > 1 ? `?t=${Date.now()}` : '';
                tempImg.src = url + cacheBuster;
            }
        }

        /** Рендерит текущий шаг диалога и обновляет UI. */
        function renderDialogueStep() {
            // Если контент не загружен, скрываем диалог и спрайты
            if (!dialogueIsLoaded || currentDialogue.length === 0) {
                document.getElementById('dialogueWrapper').classList.add('hidden');
                spriteLeftContainer.classList.add('hidden');
                spriteRightContainer.classList.add('hidden');
                vnViewerElement.style.backgroundImage = `url('${DEFAULT_BG_B64}')`;
                return;
            }

            const step = currentDialogue[currentDialogueIndex];
            const currentSpeakerElement = document.getElementById('currentSpeaker');
            const currentTextElement = document.getElementById('currentText');

            // 1. Фон (Работает)
            const bgFileName = step.background; 
            let finalBgUrl;

            if (bgFileName && !bgFileName.startsWith('data:')) {
                finalBgUrl = BACKGROUND_BASE_PATH + bgFileName; 
                loadExternalImageWithPersistence(finalBgUrl, vnViewerElement, true);
            } else {
                finalBgUrl = bgFileName || DEFAULT_BG_B64;
                vnViewerElement.style.backgroundImage = `url('${finalBgUrl}')`;
            }


            // 2. Спрайты и Затемнение
            const activeSpeakerPosition = step.position ? step.position.toLowerCase() : null;

            // Сброс и скрытие всех спрайтов
            spriteLeftContainer.classList.add('hidden');
            spriteRightContainer.classList.add('hidden');
            spriteLeftElement.classList.remove('dimmed-sprite');
            spriteRightElement.classList.remove('dimmed-sprite');
            
            // Обновление и показ нужного спрайта
            if (step.sprite && step.position) {
                const isLeft = step.position.toLowerCase() === 'left';
                const container = isLeft ? spriteLeftContainer : spriteRightContainer;
                const imageElement = isLeft ? spriteLeftElement : spriteRightElement;
                
                const spriteFileNameOrB64 = spritePath(step.sprite); 
                let finalSpriteUrl;
                
                container.classList.remove('hidden'); // Показываем контейнер спрайта

                if (spriteFileNameOrB64.startsWith('data:')) {
                    // Base64 (плейсхолдер)
                    finalSpriteUrl = spriteFileNameOrB64;
                    imageElement.src = finalSpriteUrl;
                } else {
                    // Внешний URL
                    finalSpriteUrl = SPRITE_BASE_PATH + spriteFileNameOrB64; 
                    
                    // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Сброс src перед вызовом загрузчика для внешних файлов
                    imageElement.src = ""; 
                    
                    // Использование механизма повтора для внешних URL
                    loadExternalImageWithPersistence(finalSpriteUrl, imageElement, false);
                }
                
                // --- ДЕБАГ ЛОГ ---
                const logUrl = finalSpriteUrl.startsWith('data:') ? 'Base64 Placeholder' : finalSpriteUrl;
                console.log(`[DEBUG RENDER] Спрайт: ${step.sprite}, Позиция: ${step.position}, Используется URL: ${logUrl}`);
                // ---------------
            } 
            
            // Применение Затемнения
            if (activeSpeakerPosition === 'right' && !spriteLeftContainer.classList.contains('hidden')) {
                spriteLeftElement.classList.add('dimmed-sprite');
            } else if (activeSpeakerPosition === 'left' && !spriteRightContainer.classList.contains('hidden')) {
                spriteRightElement.classList.add('dimmed-sprite');
            }

            // 3. Текст и Имя Спикера
            document.getElementById('dialogueWrapper').classList.remove('hidden');
            
            if (step.speaker) {
                currentSpeakerElement.textContent = step.speaker;
                currentSpeakerElement.parentElement.classList.remove('hidden');
            } else {
                currentSpeakerElement.textContent = "";
                currentSpeakerElement.parentElement.classList.add('hidden');
            }
            
            currentTextElement.textContent = step.text || "";
        }
        
        /** * Асинхронно пытается загрузить выбранную главу, используя Exponential Backoff. */
        async function updateStoryContent(startIndex = 0) {
            const lang = document.getElementById('languageSelect').value; 
            const fullStoryKey = document.getElementById('chapterSelect').value; 
            const loadButton = document.getElementById('loadButton');
            const loadTextElement = document.getElementById('loadText');
            
            if (!fullStoryKey) return;

            const expectedFilePath = `${STORY_BASE_PATH}${lang}/${fullStoryKey}.json`;

            loadButton.disabled = true;
            loadTextElement.textContent = "Загрузка...";
            
            const attemptLoad = async (attempt = 1) => {
                
                let success = false;
                let data = null;

                try {
                    const response = await fetch(expectedFilePath);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    data = await response.json();
                    success = true;
                } catch (e) {
                    console.error(`[Content] Критическая ошибка загрузки главы: ${expectedFilePath} (Попытка ${attempt}).`, e);
                }

                if (success && data) {
                    // --- УСПЕХ: Обновление глобального состояния ---
                    currentDialogue = data.dialogue || [];
                    currentDialogueIndex = Math.min(startIndex, currentDialogue.length - 1);
                    currentDialogueIndex = Math.max(0, currentDialogueIndex); 
                    dialogueIsLoaded = true;
                    
                    // --- Обновление UI ---
                    loadTextElement.textContent = "Загружено";
                    renderDialogueStep();

                    setTimeout(() => {
                        loadTextElement.textContent = i18n[lang].loadText;
                        loadButton.disabled = false;
                    }, 1500);

                } else {
                    // --- ПОВТОРНАЯ ПОПЫТКА: Вычисление задержки (Exponential Backoff) ---
                    const delay = Math.min(MAX_DELAY_MS, INITIAL_DELAY_MS * Math.pow(2, attempt - 1));
                    
                    loadTextElement.textContent = `Повтор (${attempt})...`;

                    // Рекурсивный вызов через setTimeout для повтора
                    setTimeout(() => {
                        // Максимальное количество попыток для загрузки контента
                        if (attempt >= 5) {
                            loadTextElement.textContent = "Ошибка загрузки";
                            console.error(`[Content] Окончательный сбой загрузки контента главы после 5 попыток.`);
                            loadButton.disabled = false;
                            return;
                        }
                        attemptLoad(attempt + 1);
                    }, delay);
                }
            };
            
            // Запуск первой попытки
            attemptLoad();
        }

        // ====================================================================
        // === UI & I18N FUNCTIONS ===
        // ====================================================================

        /**
         * Показывает временное сообщение вверху экрана.
         */
        function alertMessage(message) {
            const header = document.getElementById('header');
            const msgBox = document.createElement('div');
            msgBox.textContent = message;
            msgBox.className = 'fixed top-1 right-1/2 translate-x-1/2 p-2 bg-red-600 text-white rounded-lg shadow-xl z-50 text-sm transition-opacity duration-300';
            header.appendChild(msgBox);
            
            setTimeout(() => {
                msgBox.style.opacity = '0';
                setTimeout(() => msgBox.remove(), 300);
            }, 5000);
        }

        function updateI18nStrings() {
            const lang = document.getElementById('languageSelect').value;
            const text = i18n[lang];

            document.getElementById('headerTitle').textContent = text.headerTitle;
            document.getElementById('labelStoryType').textContent = text.labelStoryType;
            document.getElementById('labelChapter').textContent = text.labelChapter;
            document.getElementById('loadText').textContent = text.loadText;
            document.getElementById('resetButton').textContent = text.resetProgress;
            
            const typeSelect = document.getElementById('storyTypeSelect');
            const currentType = typeSelect.value;
            typeSelect.innerHTML = '';
            
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "---";
            typeSelect.appendChild(defaultOption);

            for (const key in STORY_GROUPS) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = STORY_GROUPS[key][lang] || STORY_GROUPS[key].ru; // Используем RU как резерв
                if (key === currentType) {
                    option.selected = true;
                }
                typeSelect.appendChild(option);
            }
        }

        /** * Обновляет выпадающий список глав. */
        function updateChapterSelect(skipSideEffects = false) {
            const typeKey = document.getElementById('storyTypeSelect').value;
            const select = document.getElementById('chapterSelect');
            const lang = document.getElementById('languageSelect').value;
            const currentChapterKey = select.value; 

            select.innerHTML = '';
            select.disabled = true; 
            
            const defaultOption = document.createElement('option');
            defaultOption.value = "";

            if (!window.storyMetadata) {
                defaultOption.textContent = i18n[lang].placeholderMetadata;
                select.appendChild(defaultOption);
                return;
            }
            
            defaultOption.textContent = "--- Выберите главу ---";
            select.appendChild(defaultOption);


            if (typeKey && STORY_GROUPS[typeKey]) {
                const prefix = STORY_GROUPS[typeKey].prefix;
                let chapterFound = false;

                for (const fullChapterKey in window.storyMetadata) {
                    if (fullChapterKey.startsWith(prefix)) {
                        const chapterData = window.storyMetadata[fullChapterKey];
                        if (chapterData && chapterData[lang]) {
                            const option = document.createElement('option');
                            option.value = fullChapterKey; 
                            option.textContent = chapterData[lang]; 
                            
                            if (fullChapterKey === currentChapterKey) {
                                 option.selected = true;
                            }
                            select.appendChild(option);
                            chapterFound = true;
                        }
                    }
                }
                
                if (chapterFound) {
                     select.disabled = false;
                }
            } 
            
            if (!skipSideEffects) {
                enableLoadButton();
                saveProgress(); 
            }
        }

        function enableLoadButton() {
            const storyId = document.getElementById('chapterSelect').value;
            document.getElementById('loadButton').disabled = !storyId;
        }

        function initializeOrUpdateUI(calledByUIEvent) {
            updateI18nStrings();
            updateChapterSelect(calledByUIEvent); 
            if (calledByUIEvent) {
                 saveProgress(); 
            }
        }

        // ====================================================================
        // === PROGRESS MANAGEMENT (USING localStorage) ===
        // ====================================================================
        
        function saveProgress() {
            const progress = {
                lang: document.getElementById('languageSelect').value,
                type: document.getElementById('storyTypeSelect').value,
                chapter: document.getElementById('chapterSelect').value, 
                index: currentDialogueIndex,
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
        }

        async function loadProgress() {
            await fetchChapterMetadata(); 
            
            const savedProgress = localStorage.getItem(STORAGE_KEY);
            
            initializeOrUpdateUI(false); 

            if (!savedProgress) {
                enableLoadButton();
                return; 
            }

            const progress = JSON.parse(savedProgress);
            const langSelect = document.getElementById('languageSelect');
            const typeSelect = document.getElementById('storyTypeSelect');
            const chapterSelect = document.getElementById('chapterSelect');
            
            if (i18n[progress.lang]) {
                langSelect.value = progress.lang;
            }
            updateI18nStrings(); 
            
            if (progress.type && STORY_GROUPS[progress.type]) {
                typeSelect.value = progress.type;
                updateChapterSelect(true); 
            }
            
            if (window.storyMetadata && typeSelect.value && progress.chapter) {
                if (Array.from(chapterSelect.options).some(opt => opt.value === progress.chapter)) {
                    chapterSelect.value = progress.chapter;
                }
            }
            enableLoadButton();
        }

        function resetProgress() {
            localStorage.removeItem(STORAGE_KEY);
            dialogueIsLoaded = false;
            currentDialogueIndex = 0;
            currentDialogue = []; 

            document.getElementById('dialogueWrapper').classList.add('hidden');
            document.getElementById('languageSelect').value = 'ru';
            
            loadProgress(); 
            
            vnViewerElement.style.backgroundImage = `url('${DEFAULT_BG_B64}')`;
            
            document.getElementById('spriteLeftContainer').classList.add('hidden');
            document.getElementById('spriteRightContainer').classList.add('hidden');
            
            alertMessage("Прогресс сброшен!");
        }
    </script>
</body>
</html>
