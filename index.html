<!-- Chosen Palette: Dark Neutrals (Black, Grey, White) with Honkai Red/Purple accents for UI elements. -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Houkai Gakuen 2 Архив Сюжета</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #5c5c5c; /* Фон сайта */
            color: #e5e7eb;
            transition: background-image 0.5s ease;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        /* VN Overlay for fixed size box */
        .vn-overlay {
            background-color: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
        }
        /* Speaker Name Styling for LEFT ALIGNMENT */
        .speaker-name {
            background-color: #2a2a2a;
            color: #ca7cfe;
            padding: 4px 12px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            display: inline-block;
            font-weight: bold;
        }
        .sprite {
            position: absolute;
            bottom: 0;
            max-height: 95%; /* Ограничение высоты спрайта */
            transition: opacity 0.3s ease, transform 0.3s ease, left 0.3s ease; /* Добавлен opacity для диммирования/скрытия */
            z-index: 10;
        }
        .dimmed {
            opacity: 0.4 !important; /* Принудительное затемнение */
            filter: brightness(0.7); /* Дополнительное визуальное затемнение */
            pointer-events: none; /* Заблокировать взаимодействие */
        }
        /* Custom styles for Dialogue Log entries */
        .log-entry {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .log-entry:hover {
            background-color: #333;
        }
        .log-speaker {
            font-weight: bold;
            color: #ca7cfe;
            display: block;
        }
        .log-text {
            color: #ccc;
        }
        .current-log-entry {
            background-color: #4a4a4a !important; /* Выделение текущей реплики */
            border-left: 3px solid #ca7cfe;
            padding-left: 12px;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- 1. Header Bar -->
    <header id="header" class="fixed top-0 left-0 right-0 z-50 p-4 shadow-xl text-white" style="background-color: #2a2a2a;">
        <div class="flex justify-between items-center max-w-7xl mx-auto">
            <h1 id="headerTitle" class="text-xl font-bold tracking-wider">Houkai Gakuen 2 архив сюжета</h1>
            
            <div class="flex items-center space-x-4">
                <button id="resetButton" onclick="resetProgress()" class="px-3 py-1 bg-red-800 hover:bg-red-700 rounded-full transition duration-150 text-sm">Сброс</button>
                <button id="helpButton" onclick="showHelpModal()" class="px-3 py-1 bg-gray-600 hover:bg-gray-500 rounded-full transition duration-150 text-sm">?</button>
                <select id="languageSelect" onchange="updateUI()" class="bg-gray-700 text-white rounded-lg p-2 cursor-pointer transition hover:ring-2 ring-red-400">
                    <option value="ru">Русский</option>
                    <option value="en">English</option>
                    <option value="cn">中文</option>
                </select>
            </div>
        </div>
    </header>

    <!-- 2. Main Content Area -->
    <main class="pt-20 pb-4 px-4 max-w-7xl mx-auto min-h-screen">
        
        <!-- Controls Panel -->
        <div class="bg-gray-700 p-4 rounded-xl shadow-lg mb-6 flex flex-wrap gap-4 items-end">
            <div class="flex-1 min-w-[180px]">
                <label for="storyTypeSelect" id="labelStoryType" class="block text-sm font-medium mb-1 text-gray-300">Тип сюжета</label>
                <select id="storyTypeSelect" onchange="updateChapterSelect()" class="w-full bg-gray-800 text-white rounded-lg p-2.5 cursor-pointer focus:ring-red-400 focus:border-red-400 transition">
                    <!-- Options populated by JS -->
                </select>
            </div>

            <div class="flex-1 min-w-[250px]">
                <label for="chapterSelect" id="labelChapter" class="block text-sm font-medium mb-1 text-gray-300">Сюжет (Глава)</label>
                <select id="chapterSelect" onchange="enableLoadButton()" class="w-full bg-gray-800 text-white rounded-lg p-2.5 cursor-pointer focus:ring-red-400 focus:border-red-400 transition">
                    <!-- Options populated by JS -->
                </select>
            </div>
            
            <button id="loadButton" onclick="updateStoryContent(0)" class="min-w-[120px] bg-red-600 hover:bg-red-700 text-white font-bold py-2.5 px-4 rounded-lg shadow-md transition duration-150 disabled:opacity-50" disabled>
                <span id="loadText">Загрузить</span>
            </button>
        </div>

        <!-- 3. Visual Novel Viewer (Main View) -->
        <div id="vnViewer" class="relative w-full aspect-[16/9] bg-gray-900 rounded-xl shadow-2xl overflow-hidden flex flex-col justify-end transition-colors duration-500" 
             style="min-height: 400px; background-image: url('https://placehold.co/1920x1080/2a2a2a/fca5a5?text=Выбор+сюжета'); background-size: cover; background-position: center;"
             onclick="handleVnClick(event)"> <!-- Обработчик клика добавлен сюда -->

            <!-- Log Toggle Button (New feature) -->
            <button id="logToggleButton" onclick="toggleLog()" 
                class="absolute top-4 right-4 z-30 bg-gray-800 hover:bg-red-700 text-white p-3 rounded-full shadow-lg transition duration-150 hidden">
                <!-- SVG for Book Open icon: https://www.svgrepo.com/show/521518/book-open.svg -->
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.22 4.5 7.5 4.5A2.75 2.75 0 004.75 7.25v9.5A2.75 2.75 0 007.5 19.5c1.72 0 3.332-.977 4.5-2.753m0-13C13.168 5.477 14.78 4.5 16.5 4.5A2.75 2.75 0 0119.25 7.25v9.5A2.75 2.75 0 0116.5 19.5c-1.72 0-3.332-.977-4.5-2.753"></path>
                </svg>
            </button>
            
            <!-- Sprite Container -->
            <div id="spriteContainer" class="absolute inset-0 z-10 pointer-events-none flex justify-center items-end p-4">
                <!-- Sprites are inserted here by JS -->
            </div>

            <!-- Dialogue Wrapper: Centered container for the dialogue box and speaker name -->
            <div id="dialogueWrapper" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 transition-all duration-300 opacity-100 hidden">
                
                <!-- Speaker Name Container (Absolute positioning relative to Dialogue Content Box) -->
                <!-- Speaker name is always left-aligned relative to the dialogue box's content start -->
                <div id="currentSpeakerContainer" class="absolute top-0 transform -translate-y-full left-10 hidden">
                    <div id="currentSpeaker" class="speaker-name text-lg rounded-t-lg rounded-b-none"></div>
                </div>
                
                <!-- Dialogue Text Content Box -->
                <div id="dialogueContentBox" 
                    class="vn-overlay w-[900px] h-[200px] p-8 flex items-center justify-start 
                            rounded-xl shadow-2xl overflow-hidden"
                    onclick="event.stopPropagation()"> <!-- Предотвращаем срабатывание клика по VN Viewer -->
                    <p id="currentText" class="text-xl leading-snug transition-opacity duration-300">Текст диалога...</p>
                </div>
            </div>


            <!-- Navigation Buttons (hidden, navigation handled by click) -->
            <div id="navButtons" class="absolute bottom-6 right-6 flex space-x-3 z-30 opacity-0 transition-opacity duration-300 hidden">
                <button id="prevButton" onclick="navigateDialogue(-1)" class="bg-gray-800 hover:bg-gray-700 text-white p-3 rounded-full shadow-lg transition duration-150 disabled:opacity-30">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                </button>
                <button id="nextButton" onclick="navigateDialogue(1)" class="bg-red-600 hover:bg-red-500 text-white p-3 rounded-full shadow-lg transition duration-150 disabled:opacity-30">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                </button>
            </div>
        </div>

    </main>
    
    <!-- Help Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden" onclick="showHelpModal()">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-lg w-11/12 transform transition-all duration-300 scale-95" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-3">
                <h3 class="text-xl font-bold text-red-400">О приложении</h3>
                <button onclick="showHelpModal()" class="text-gray-400 hover:text-white transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <p id="helpContent" class="text-gray-300 leading-relaxed"></p>
        </div>
    </div>

    <!-- Dialogue Log Modal (New structure: Fixed Overlay) -->
    <div id="logModal" class="fixed inset-0 z-40 hidden" onclick="toggleLog()">
        <div id="logContent" 
            class="absolute top-0 right-0 h-full w-full sm:w-1/3 bg-gray-900 border-l-4 border-red-500 shadow-2xl p-6 transform translate-x-full transition-transform duration-300"
            onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-700">
                <h2 class="text-xl font-bold text-red-400">Лог Диалогов</h2>
                <button onclick="toggleLog()" class="text-gray-400 hover:text-white transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            <div id="logContainer" class="h-[calc(100%-60px)] overflow-y-auto">
                <!-- Dialogue entries will be added here by JS -->
                <p class="text-gray-500 text-center mt-8">Загрузите сюжет, чтобы увидеть лог.</p>
            </div>
        </div>
    </div>

    <script>
        const STORAGE_KEY = 'hg2_story_progress';
        const SPRITE_BASE_PATH = 'images/sprites/'; 

        let currentDialogue = [];
        let currentDialogueIndex = 0;
        let dialogueIsLoaded = false;
        
        /** * Переменная для отслеживания текущего активного спрайта в DOM. 
         * Используется для применения эффектов (затемнение/скрытие) на предыдущий спрайт.
         */
        let currentSpriteElement = null; 
        // --- I18N DATA ---
        const i18n = {
            ru: {
                headerTitle: "Houkai Gakuen 2 архив сюжета",
                labelStoryType: "Тип сюжета",
                labelChapter: "Сюжет (Глава)",
                loadText: "Загрузить",
                resetProgress: "Сброс",
                errorFetch: "Ошибка загрузки контента: файл не найден или проблема с сетью.",
                logTitle: "Лог Диалогов",
                helpTitle: "Как пользоваться архивом:",
                helpText: "Это интерактивный архив сюжетов Honkai Gakuen 2.\n\n1. Используйте верхние выпадающие списки, чтобы выбрать [Тип сюжета] и конкретную [Главу].\n2. Нажмите [Загрузить].\n3. В окне визуальной новеллы используйте клик в правой части для перехода Далее и клик в левой части для перехода Назад.\n4. Ваш прогресс автоматически сохраняется.\n5. Чтобы открыть [Лог диалогов], нажмите на иконку книги в правом верхнем углу VN-окна."
            },
            en: {
                headerTitle: "Houkai Gakuen 2 Story Archive",
                labelStoryType: "Story Type",
                labelChapter: "Story (Chapter)",
                loadText: "Load",
                resetProgress: "Reset",
                errorFetch: "Content loading error: file not found or network issue.",
                logTitle: "Dialogue Log",
                helpTitle: "How to use the Archive:",
                helpText: "This is an interactive story archive for Honkai Gakuen 2.\n\n1. Use the top dropdowns to select the [Story Type] and a specific [Chapter].\n2. Click [Load].\n3. In the Visual Novel viewer, use click on the right side to go Next and click on the left side to go Back.\n4. Your progress is saved automatically.\n5. To open the [Dialogue Log], click the book icon in the top right of the VN viewer."
            },
            cn: {
                headerTitle: "崩坏学园2 剧情档案",
                labelStoryType: "剧情类型",
                labelChapter: "剧情 (章节)",
                loadText: "加载",
                resetProgress: "重置",
                errorFetch: "内容加载错误：未找到文件或网络问题。",
                logTitle: "对话记录",
                helpTitle: "如何使用档案：",
                helpText: "这是一个崩坏学园2的交互式剧情档案。\n\n1. 使用顶部下拉列表选择剧情类型和特定章节。\n2. 点击加载。\n3. 在视觉小说查看器中，使用右侧点击进行下一页，左侧点击进行上一页。\n4. 您的进度将自动保存。\n5. 要打开对话记录，请点击 VN 查看器右上角的书本图标。"
            }
        };


        // --- CORE UI FUNCTIONS ---

        /** Toggles the visibility of the dialogue log modal. */
        function toggleLog() {
            const modal = document.getElementById('logModal');
            const content = document.getElementById('logContent');
            const logContainer = document.getElementById('logContainer');

            if (modal.classList.contains('hidden')) {
                if (dialogueIsLoaded) {
                    populateDialogueLog();
                    modal.classList.remove('hidden');
                    setTimeout(() => {
                        content.classList.remove('translate-x-full');
                        const currentEntry = logContainer.querySelector(`.current-log-entry`);
                        if (currentEntry) {
                            currentEntry.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 10);
                }
            } else {
                content.classList.add('translate-x-full');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300); 
            }
        }

        /** Handles click on VN Viewer area for navigation. */
        function handleVnClick(event) {
            if (!dialogueIsLoaded || !document.getElementById('logModal').classList.contains('hidden')) return;
            
            const vnViewer = document.getElementById('vnViewer');
            const rect = vnViewer.getBoundingClientRect();
            const clickX = event.clientX;
            
            const relativeX = (clickX - rect.left) / rect.width;

            if (relativeX > 0.6) { // Click on right 40% (Next)
                navigateDialogue(1);
            } else if (relativeX < 0.4) { // Click on left 40% (Previous)
                navigateDialogue(-1);
            }
        }

        /** Enables the load button when a chapter is selected. */
        function enableLoadButton() {
            const storyId = document.getElementById('chapterSelect').value;
            document.getElementById('loadButton').disabled = !storyId;
        }

        /** Updates all UI elements based on the current language selection. */
        function updateUI() {
            const lang = document.getElementById('languageSelect').value;
            const text = i18n[lang];

            document.getElementById('headerTitle').textContent = text.headerTitle;
            document.getElementById('labelStoryType').textContent = text.labelStoryType;
            document.getElementById('labelChapter').textContent = text.labelChapter;
            document.getElementById('loadText').textContent = text.loadText;
            document.getElementById('resetButton').textContent = text.resetProgress;
            
            document.getElementById('helpContent').innerHTML = `
                <h4 class="text-lg font-semibold text-red-400 mb-2">${text.helpTitle}</h4>
                <p class="whitespace-pre-line">${text.helpText}</p>`;
            
            updateStoryTypeSelect();
            updateChapterSelect();
            enableLoadButton();
        }

        /** Populates the Story Type dropdown based on the current language. */
        function updateStoryTypeSelect() {
            const select = document.getElementById('storyTypeSelect');
            const lang = document.getElementById('languageSelect').value;
            const currentType = select.value;
            
            select.innerHTML = '';
            
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "---";
            select.appendChild(defaultOption);

            for (const key in storyData) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = storyData[key][lang];
                if (key === currentType) {
                    option.selected = true;
                }
                select.appendChild(option);
            }
        }

        /** Populates the Chapter dropdown based on the selected Story Type and language. */
        function updateChapterSelect() {
            const typeKey = document.getElementById('storyTypeSelect').value;
            const select = document.getElementById('chapterSelect');
            const lang = document.getElementById('languageSelect').value;
            
            select.innerHTML = '';
            
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "---";
            select.appendChild(defaultOption);

            if (typeKey && storyData[typeKey] && storyData[typeKey].chapters) {
                const chapters = storyData[typeKey].chapters;
                for (const key in chapters) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = chapters[key][lang];
                    select.appendChild(option);
                }
                select.disabled = false;
            } else {
                select.disabled = true;
            }
            enableLoadButton();
        }

        /** Asynchronously loads the selected story chapter JSON or uses mock data. */
        async function updateStoryContent(startIndex = 0) {
            const storyType = document.getElementById('storyTypeSelect').value;
            const storyId = document.getElementById('chapterSelect').value;
            const currentLang = document.getElementById('languageSelect').value;
            const vnViewer = document.getElementById('vnViewer');
            const loadButton = document.getElementById('loadButton');
            const loadText = document.getElementById('loadText');
            
            if (!storyType || !storyId) return;

            const fileNameKey = `${storyType}_${storyId}`;
            
            loadButton.disabled = true;
            loadText.textContent = i18n[currentLang].loadText + '...';
            
            try {
                let data;
                if (mockDialogueData[fileNameKey]) {
                    // Используем заглушку для демонстрации новых функций
                    data = mockDialogueData[fileNameKey];
                } else {
                    // В реальном сценарии, пытаемся загрузить файл
                    const fileName = `story/${currentLang}/${storyType}_${storyId}.json`;
                    const response = await fetch(fileName);
                    if (!response.ok) {
                         // Если файл не найден, но это не демо-файл, показываем ошибку
                         throw new Error(i18n[currentLang].errorFetch + ` (File: ${fileName})`);
                    }
                    data = await response.json();
                }

                if (!data.dialogue || !Array.isArray(data.dialogue)) {
                    throw new Error("JSON structure error: 'dialogue' array not found at the root level.");
                }

                currentDialogue = data.dialogue;
                
                currentDialogueIndex = Math.min(startIndex, currentDialogue.length - 1);
                if (currentDialogueIndex < 0) currentDialogueIndex = 0;

                dialogueIsLoaded = true;
                
                // Сброс всех спрайтов при загрузке новой главы
                document.getElementById('spriteContainer').innerHTML = '';
                currentSpriteElement = null;

                document.getElementById('dialogueWrapper').classList.remove('hidden');
                document.getElementById('logToggleButton').classList.remove('hidden'); 
                
                renderDialogue();
                saveProgress(); 

            } catch (error) {
                console.error("Error loading story:", error.message);
                currentDialogue = [];
                dialogueIsLoaded = false;
                vnViewer.style.backgroundImage = `url('https://placehold.co/1920x1080/aa0000/ffffff?text=Ошибка+Загрузки')`;
                
                document.getElementById('dialogueWrapper').classList.add('hidden');
                document.getElementById('logToggleButton').classList.add('hidden'); 
                
            } finally {
                loadButton.disabled = false;
                loadText.textContent = i18n[currentLang].loadText;
            }
        }

        // ... (loadProgress, resetProgress, populateDialogueLog, jumpToDialogue - UNCHANGED) ...

        /** Renders the current dialogue line, sprite, and updates navigation buttons and log. */
        function renderDialogue() {
            if (!dialogueIsLoaded || currentDialogue.length === 0) return;

            const dialogue = currentDialogue[currentDialogueIndex];
            const vnViewer = document.getElementById('vnViewer');
            const spriteContainer = document.getElementById('spriteContainer');
            const currentSpeaker = document.getElementById('currentSpeaker');
            const currentText = document.getElementById('currentText');
            const currentSpeakerContainer = document.getElementById('currentSpeakerContainer');
            
            // 1. Update Background
            if (dialogue.background) {
                vnViewer.style.backgroundImage = `url('${dialogue.background}')`;
            }

            // 2. Sprite Management: Handle previous sprite action and render new one
            
            const actionPrev = dialogue.action_prev_sprite; // 'dim', 'hide', or undefined/null
            
            // 2.1. Handle Previous Sprite Action (Dim/Hide)
            if (currentSpriteElement) {
                if (actionPrev === 'dim') {
                    // Затемнить текущий спрайт, оставляя его в DOM
                    currentSpriteElement.classList.add('dimmed');
                    currentSpriteElement.style.zIndex = 9; // Отправляем на задний план
                } else if (actionPrev === 'hide') {
                    // Скрыть текущий спрайт, убрать его из DOM после анимации
                    currentSpriteElement.style.opacity = '0';
                    setTimeout(() => {
                        currentSpriteElement.remove();
                        currentSpriteElement = null;
                    }, 300); // Соответствует длительности CSS-transition
                } else {
                    // Если нет явного действия, спрайт остается как есть (часть мульти-спрайтовой сцены)
                    // В данной одно-спрайтовой архитектуре мы просто гарантируем, что он яркий, если его не собираются заменить
                    currentSpriteElement.classList.remove('dimmed');
                    currentSpriteElement.style.zIndex = 10;
                }
            }

            // 2.2. Render NEW Sprite
            if (dialogue.sprite) {
                // Если новый спрайт определен, мы либо создаем новый элемент, либо обновляем старый,
                // если предыдущий спрайт был скрыт/заменен. 
                
                // Для простоты, если есть новый спрайт, удаляем все старые, кроме тех, что затемнены.
                // В этой одно-спрайтовой реализации, мы будем поддерживать только один яркий спрайт + затемненные.
                
                const newCharId = dialogue.sprite_id || dialogue.speaker;
                let spriteEl = spriteContainer.querySelector(`img[data-char-id="${newCharId}"]`);

                if (!spriteEl) {
                    // Если спрайт для этого персонажа не существует (или был скрыт)
                    const img = document.createElement('img');
                    img.classList.add('sprite');
                    img.setAttribute('data-char-id', newCharId || 'unknown');
                    spriteEl = img;
                    spriteContainer.appendChild(spriteEl);

                    const spriteSrc = dialogue.sprite.startsWith('http') ? dialogue.sprite : SPRITE_BASE_PATH + dialogue.sprite;
                    spriteEl.src = spriteSrc; 
                    spriteEl.alt = dialogue.speaker || 'Персонаж';
                    spriteEl.style.opacity = '0'; // Для плавного появления
                    spriteEl.onerror = () => {
                         spriteEl.src = `https://placehold.co/200x400/808080/ffffff?text=${dialogue.speaker || 'Char'}`; 
                         console.error(`Sprite not found: ${spriteSrc}.`);
                    }; 
                } else {
                    // Если спрайт существует (например, был затемнен или меняет позу)
                    const spriteSrc = dialogue.sprite.startsWith('http') ? dialogue.sprite : SPRITE_BASE_PATH + dialogue.sprite;
                    spriteEl.src = spriteSrc;
                }

                // Установка позиции (X-координата в процентах)
                const xPercent = dialogue.sprite_x !== undefined ? dialogue.sprite_x : 50;
                spriteEl.style.left = `${xPercent}%`;
                spriteEl.style.transform = `translateX(-50%)`; 

                // Сделать новый/активированный спрайт ярким и вывести вперед
                spriteEl.classList.remove('dimmed');
                spriteEl.style.opacity = '1';
                spriteEl.style.zIndex = 10;
                
                currentSpriteElement = spriteEl; // Обновляем ссылку на активный спрайт

            } else if (actionPrev === 'dim' || actionPrev === 'hide') {
                 // Если нет нового спрайта, но есть команда на действие (и она выполнена выше)
                 // currentSpriteElement уже обновлен/затемнен.
            } else if (currentSpriteElement) {
                // Если нет спрайта и нет действия, но есть предыдущий спрайт, убеждаемся, что он яркий (если это не Голос за кадром)
                currentSpriteElement.classList.remove('dimmed');
                currentSpriteElement.style.zIndex = 10;
            }


            // 3. Update Text and Speaker
            currentText.style.opacity = '0';
            setTimeout(() => {
                currentText.textContent = dialogue.text;
                currentText.style.opacity = '1';
            }, 50); 

            if (dialogue.speaker) {
                currentSpeaker.textContent = dialogue.speaker;
                currentSpeakerContainer.classList.remove('hidden');
            } else {
                currentSpeaker.textContent = '';
                currentSpeakerContainer.classList.add('hidden');
            }

            // 4. Update Log Highlighting and content if the log is open
            const logContainer = document.getElementById('logContainer');
            if (!document.getElementById('logModal').classList.contains('hidden')) {
                populateDialogueLog();
                const currentEntry = logContainer.querySelector(`.current-log-entry`);
                if (currentEntry) {
                    currentEntry.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        /** Handles navigation (next/previous) in the dialogue array. */
        function navigateDialogue(direction) {
            const newIndex = currentDialogueIndex + direction;
            
            if (newIndex >= 0 && newIndex < currentDialogue.length) {
                currentDialogueIndex = newIndex;
                renderDialogue();
                saveProgress(); 
            } else if (newIndex >= currentDialogue.length) {
                // Если дошли до конца, перезагружаем на начальный экран
                document.getElementById('dialogueWrapper').classList.add('hidden');
                document.getElementById('logToggleButton').classList.add('hidden');
                document.getElementById('spriteContainer').innerHTML = '';
                currentSpriteElement = null;
                const currentLang = document.getElementById('languageSelect').value;
                 document.getElementById('vnViewer').style.backgroundImage = `url('https://placehold.co/1920x1080/2a2a2a/fca5a5?text=${i18n[currentLang].loadText.replace('Загрузить', 'Конец+Сюжета')}')`;
            }
        }
        
        /** Toggles the help modal. */
        function showHelpModal() {
            document.getElementById('helpModal').classList.toggle('hidden');
        }
        
        // --- PROGRESS MANAGEMENT (UNCHANGED) ---
        function saveProgress() {
            const progress = {
                lang: document.getElementById('languageSelect').value,
                type: document.getElementById('storyTypeSelect').value,
                chapter: document.getElementById('chapterSelect').value,
                index: currentDialogueIndex
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
        }

        function loadProgress() {
            const savedProgress = localStorage.getItem(STORAGE_KEY);
            if (!savedProgress) return;

            const progress = JSON.parse(savedProgress);
            
            const langSelect = document.getElementById('languageSelect');
            if (i18n[progress.lang]) {
                langSelect.value = progress.lang;
            }

            const typeSelect = document.getElementById('storyTypeSelect');
            if (storyData[progress.type]) {
                typeSelect.value = progress.type;
            }

            updateUI(); 

            const chapterSelect = document.getElementById('chapterSelect');
            if (storyData[progress.type]?.chapters[progress.chapter]) {
                chapterSelect.value = progress.chapter;
            }

            if (typeSelect.value && chapterSelect.value) {
                updateStoryContent(progress.index);
            }
        }

        function resetProgress() {
            localStorage.removeItem(STORAGE_KEY);
            document.getElementById('dialogueWrapper').classList.add('hidden');
            document.getElementById('logToggleButton').classList.add('hidden'); 
            document.getElementById('spriteContainer').innerHTML = '';
            currentSpriteElement = null;

            document.getElementById('logModal').classList.add('hidden');
            document.getElementById('logContent').classList.add('translate-x-full');

            document.getElementById('languageSelect').value = 'ru';
            updateUI(); 
            const currentLang = document.getElementById('languageSelect').value;
            const vnViewer = document.getElementById('vnViewer');
            vnViewer.style.backgroundImage = `url('https://placehold.co/1920x1080/2a2a2a/fca5a5?text=${i18n[currentLang].loadText.replace('Загрузить', 'Прогресс+сброшен')}')`;
        }
        
        function populateDialogueLog() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '';

            if (currentDialogue.length === 0) {
                 logContainer.innerHTML = '<p class="text-gray-500 text-center mt-8">Сюжет не загружен.</p>';
                 return;
            }

            for (let index = 0; index <= currentDialogueIndex; index++) {
                const line = currentDialogue[index];
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.setAttribute('data-index', index);
                entry.onclick = () => {
                    jumpToDialogue(index);
                    toggleLog(); 
                };

                if (line.speaker) {
                    const speaker = document.createElement('span');
                    speaker.className = 'log-speaker';
                    speaker.textContent = line.speaker + ': ';
                    entry.appendChild(speaker);
                }

                const text = document.createElement('span');
                text.className = 'log-text';
                text.textContent = line.text;
                entry.appendChild(text);

                if (index === currentDialogueIndex) {
                    entry.classList.add('current-log-entry');
                }

                logContainer.appendChild(entry);
            }
        }

        function jumpToDialogue(index) {
            currentDialogueIndex = index;
            renderDialogue();
            saveProgress();
        }

        // --- INITIALIZATION ---
        window.onload = () => {
            loadProgress(); 
            updateUI(); 
        };
    </script>
</body>
</html>
